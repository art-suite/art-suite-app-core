import &StandardImport

class MultitouchManager extends BaseClass
  constructor: ->
    @_activePointers = []
    @_resetMultitouchTracking()

  ###############################
    INFO
  ###############################

  @getter
    :multitouchOccured
    :activePointers
    firstActivePointer:   -> @_activePointers[0]
    secondActivePointer:  -> @_activePointers[1]
    numActivePointers:    -> @_activePointers.length

    moveToPoint: ->
      switch @numActivePointers
      when 0 then point0
      when 1 then @firstActivePointer.location
      else
        @firstActivePointer.location.average
          @secondActivePointer.location

    multitouchTransform: ->
      @_correctionMatrix.mul @uncorrectedMultitouchTransform

    multitouchTransformParts: ->
      @_getMultitouchTransformParts
        @multitouchTransform
        @moveToPoint

  getActivePointer: (id) ->
    find pointer in @_activePointers when pointer.id == id

  moveToPointIn: ({absToElementMatrix}) ->
    absToElementMatrix.transform @moveToPoint

  ###
    multitouchTransformIn:
    NOTES:
      @multitouchTransform is an absSpace-to-absSpace matrix (Abs->Abs)
      We want an elementSpace-to-elementSpace matrix (Element->Element)
      Therefore:
        absToElementMatrix.inverted (Element->Abs)
        *
        @multitouchTransform        (Abs->Abs)
        *
        absToElementMatrix          (Abs->Element)

  multitouchTransformIn: ({absToElementMatrix}) ->
    absToElementMatrix
    .invertAndMul @multitouchTransform
    .mul          absToElementMatrix

  multitouchTransformPartsIn: (element) ->
    @_getMultitouchTransformParts
      @multitouchTransformIn element
      @moveToPointIn element

  ###############################
    ACTIONS
  ###############################

  addActivePointer: (pointer) ->
    unless @getActivePointer pointer.id
      @ extract multitouchTransform
      @_activePointers.push pointer
      @_correctMultitouchTracking multitouchTransform
      @_multitouchOccured = true if @numActivePointers > 1

    @

  updateActivePointer: (pointer) ->
    each p, i in @_activePointers when p.id == pointer.id
      @_activePointers[i] = pointer
    @

  removeActivePointer: (pointer) ->
    @ extract multitouchTransform
    @_activePointers = array p in @_activePointers when p.id != pointer.id
    @_correctMultitouchTracking multitouchTransform
    @_resetMultitouchTracking() if @numActivePointers == 0

    @

  ###############################
    PRIVATE
  ###############################

  _getMultitouchTransformParts: (transform, moveToPoint) ->
    rotate:     transform.angle
    scale:      transform.exactScaler
    translate:  moveToPoint.sub transform.inverseTransform moveToPoint

  _resetMultitouchTracking: ->
    @_correctionMatrix = matrix()
    @_multitouchOccured = false

  _correctMultitouchTracking: (correctMatrix) ->
    @_correctionMatrix = correctMatrix.div @uncorrectedMultitouchTransform

  @getter
    uncorrectedMultitouchTransform: ->
      switch @numActivePointers
      when 0 then matrix()
      when 1 then Matrix.translate @firstActivePointer.totalDelta
      else
        [p1, p2] = @activePointers
        Matrix.multitouch
          p1.firstLocation
          p1.location
          p2.firstLocation
          p2.location
