import Math, &StandardImport, &GlobalEpochStatsStyle, {} &GlobalEpochStat
&Core extract GlobalEpochCycle extract globalEpochCycle

class GlobalEpochStats extends BaseClass
  @classGetter
    enabled: -> !!globalEpochCycle.globalEpochStats

  @enable: ->
    log "" Enabled globalEpochStats
    globalEpochCycle.globalEpochStats = new @
    true

  @toggle: ->
    if @enabled
      @disable()
    else
      @enable()

  @disable: ->
    log "" Disabled globalEpochStats
    globalEpochCycle.globalEpochStats = null
    false

  constructor: ->
    @reset()

  reset: ->
    @maxMs            = 2/60
    @stats            = []
    @nextEventIdIndex = 0
    @eventsById       = {}
    @eventLegend      = {}
    @_minSampleTime   = null
    @_maxSampleTime   = null

  add: (sampleTime, total, sampleSet) ->
    @stats.push ges = new GlobalEpochStat sampleTime, total, sampleSet

    @maxMs = max @maxMs, total * 1.5
    @logAndResetWhenIdle()
    @addSampleTime sampleTime

  addSampleTime: (time) ->
    @_minSampleTime = min time, @_minSampleTime || time
    @_maxSampleTime = max time, @_maxSampleTime || time

  logEvent: (name, id) ->
    now = currentSecond()
    id ?= name
    @addSampleTime now

    color = namedEventColors[name] || namedEventColors.default

    ebi = @eventsById[id] ||= {}
      name, color
      startTime:  now
      endTime:    now
      index:      @nextEventIdIndex++
      events:     []

    ebi.startTime = min now, ebi.startTime
    ebi.endTime   = max now, ebi.endTime

    @eventLegend[name] = color

    ebi.events.push {} name, color, time: now

  @getter
    minSampleTime:    -> @_minSampleTime
    maxSampleTime:    -> @_maxSampleTime
    sampleTimeRange:  -> @maxSampleTime - @minSampleTime

  drawAllSamplesForOneField: (bitmap, drawMatrix, sampleField) ->
    bitmap.size extract w, h
    @ extract sampleTimeRange, stats
    sampleWidth = floor (w / sampleTimeRange) / 60
    each stat in stats
      stat.drawSample bitmap, drawMatrix, sampleWidth, sampleField, h

  getDrawMatrix: ({w, h})->
    @ extract sampleTimeRange, minSampleTime, maxMs

    w -= legendWidth

    sampleWidth = floor (w / sampleTimeRange) / 60
    xScale = (w - sampleWidth) / sampleTimeRange
    yScale = h / maxMs

    Matrix.scaleXY  1               -1
    .translateXY    -minSampleTime, 0
    .scaleXY        xScale,         yScale
    .translateXY    legendWidth,    h

  drawLabeledHLine: (bitmap, x1, x2, y, color, label) ->
    bitmap.drawRectangle  null, rect(x1, y, x2-x1, 1),    {} color
    bitmap.drawText       point(x1, y-5), label, size:14, {} color

  drawEvents: (bitmap, drawMatrix) ->
    bitmap.size extract w, h

    eventTimeLineHeight = floor h / 20
    each {index, startTime, endTime, color, events, name}, id in @eventsById
      @drawLabeledHLine
        bitmap
        floor drawMatrix.transformX startTime, 0
        floor drawMatrix.transformX endTime,   0
        y = (index + 1) * eventTimeLineHeight
        color
        name

      each {time, name, color} in events
        x = floor drawMatrix.transformX time, 0
        bitmap.drawRectangle
          null
          rect x, y, 1, eventTimeLineHeight * 1/3
          {} color

  logStats: -> if @stats.length > 0

    unless Neptune.Art.Foundation.DevTools.DomConsole?.enabled
      logToCanvasElement = GlobalEpochCycle.activeCanvasElements[0]

    bitmap = new Bitmap size =
      logToCanvasElement?.canvasBitmap.size
      ? point 1000 600

    size extract w, h
    bitmap.clear #f
    drawMatrix = @getDrawMatrix size

    y       = floor drawMatrix.transformY 0 1/60
    tenMsY  = floor drawMatrix.transformY 0 1/100
    fiveMsY = floor drawMatrix.transformY 0 1/200
    bitmap.drawRectangle
      null
      rect    0 y, w, 1
      color:  #0007

    each sampleField in statFields
      @drawAllSamplesForOneField bitmap, drawMatrix, sampleField

    @drawLabeledHLine bitmap, 40, w, tenMsY,  #0007 10ms
    @drawLabeledHLine bitmap, 40, w, fiveMsY, #0007 5ms
    @drawEvents bitmap, drawMatrix

    totalFrames         = @stats.length
    averageFrameTimeMs  = @sampleTimeRange / totalFrames
    perfectFrameCount   = @sampleTimeRange * 60 + .5 | 0
    missedFrames        = perfectFrameCount - totalFrames
    averageFrameTimeMsY = floor drawMatrix.transformY 0, averageFrameTimeMs
    if 55 > averageFps = 1 / averageFrameTimeMs + .5 | 0
      @drawLabeledHLine bitmap, 40, w, y,
        #0007
        "" 60fps - 16.7ms

    @drawLabeledHLine bitmap, 40, w, averageFrameTimeMsY,
      #0007
      ""
        average: #{averageFps}fps (miss-rate: #{
          (100 * missedFrames / perfectFrameCount).toPrecision(2)
        }% #{missedFrames}/#{perfectFrameCount})

    y = 0
    each field in statFields
      bitmap.drawRectangle
        null
        rect    0 y, 75 23
        color:  statColors[field]

      bitmap.drawText
        point   5 y + 18
        field
        size:   16 color: :white

      y += 25

    bitmap.drawBorder null, bitmap.size, #eee

    if logToCanvasElement
      log "" showing GlobalEpochStats
      logToCanvasElement.canvasBitmap.drawBitmap null, bitmap, opacity: .9

    else
      log bitmap

  logAndResetWhenIdle: ->
    if 0 < samples = @stats.length
      timeout 1000 ->
        if samples == @stats.length && GlobalEpochStats.enabled
          @logStats()
          @reset()

  @enable() if getEnv().perfGraphs?
