import &StandardImport

suite:
  padding: ->
    renderTest
      "and drawOrder drawArea"
      render: ->
        Element
          padding: 10
          drawOrder: :red
          RectangleElement()
      test: (e) ->
        assert.eq e.drawArea, rect -10, -10, 100, 100

    renderTest
      "and children drawArea"
      render: ->
        Element
          padding: 10
          Element
            drawOrder: :red
      test: (e) ->
        assert.eq e.drawArea, rect 80

    test "pixelsPerPoint: 2", ->
      e =
        Element
          drawOrder: :grey
          size: 100

          Element
            size: 30
            drawOrder: #aaa
            padding: 10
            RectangleElement()

          Element
            location: 30
            size: 30
            drawOrder: :orange
      e.toBitmapBasic pixelsPerPoint: 2
      .then (bitmap) ->
        log {bitmap}

  nestingElements: ->
    renderTest
      "basic"
      render: ->
        Element
          size: 50
          name: :parent
          Element drawOrder: :red, name: :child
      test: (e) ->
        assert.eq e.drawArea, rect 50

    renderTest
      "padding+"
      render: ->
        Element
          size: 50
          padding: 10
          Element drawOrder: :red
      test: (e) ->
        assert.eq e.drawArea, rect 30

    renderTest
      "padding-"
      render: ->
        Element
          size: 50
          padding: -10
          Element drawOrder: :red
      test: (e) ->
        assert.eq e.drawArea, rect 70

    renderTest
      "padding clip"
      render: ->
        Element
          size: 50
          padding: 10
          clip: true
          Element drawOrder: :red, size: 100
          Element drawOrder: :orange, size: 10
      test: (e) ->
        assert.eq e.drawArea, rect 30

    renderTest
      "deep nesting"
      render: ->
        Element
          size: h: 50, wcw:1
          childrenLayout: "column"
          Element drawOrder: :red, size: 100
          Element drawOrder: :orange, size: 10
      test: (e) ->
        assert.eq e.drawArea, rect 100, 110

  shapes: ->
    renderTest
      "circle"
      render: -> Element
        size: 100
        drawOrder:
          "circle"
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: area function with params"
      render: -> Element
        size: 100
        drawOrder:
          "grey"
          rectangle:
            pos: 10
            area: ({w,h}, {pos}) -> rect pos, 0, w, h
          "orange"
      test: (e) -> assert.eq e.drawArea, rect 110, 100


    renderTest
      "rectangle: radius: 10"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: 10
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: radius: tl:20"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: tl: 20
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: ->"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: ({size}) -> rect size.x / 2, size.y / 4
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 50, 25

    renderTest
      "rectangle: area: ->"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: area: ({size}) -> rect size.x / 2, size.y / 4
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 50, 25

    renderTest
      "rectangle: rect()"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: rect 5, 5, 40, 40
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 5, 5, 40, 40

    renderTest
      "rect()"
      render: -> Element
        size: 100
        drawOrder:
          rect 5, 5, 40, 40
          "red"
      test: (e) -> assert.eq e.drawArea, rect 5, 5, 40, 40

    renderTest
      "rectangle: area: ->"
      render: -> Element
        size: 100
        drawOrder:
          rectangle:
            area: ({size}) -> rect size.div(4), size.div 2
            radius: 10
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 25, 25, 50, 50

    renderTest
      "rectangle: rect()"
      render: -> Element
        size: 100
        drawOrder:
          fill: color: "orange"
          {}
            rectangle:
              area: rect 5, 5, 40, 40
              radius: 10
            fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "custom with miter"
      render: -> Element
        size: 100
        drawOrder:
          shape: (context, area) ->
            {top, left, right, bottom, vCenter, hCenter} = area
            context.moveTo  hCenter, top
            context.lineTo  right, bottom
            context.lineTo  left, bottom
            context.closePath()
          fill: color: "orange"
          outline: lineWidth: 10
      test: (e) -> assert.eq e.drawArea, rect -15, -15, 130, 130

    renderTest
      "custom with miterLimit"
      render: -> Element
        size: 100
        drawOrder:
          shape: (context, area) ->
            {top, left, right, bottom, vCenter, hCenter} = area
            context.moveTo  hCenter, top
            context.lineTo  right, bottom
            context.lineTo  left, bottom
            context.closePath()
          fill: color: "orange"
          outline: lineWidth: 10 miterLimit: 2
      test: (e) -> assert.eq e.drawArea, rect -10, -10, 120, 120

    renderTest
      "custom with round"
      render: -> Element
        size: 100
        drawOrder:
          shape: (context, area) ->
            {top, left, right, bottom, vCenter, hCenter} = area
            context.moveTo  hCenter, top
            context.lineTo  right, bottom
            context.lineTo  left, bottom
            context.closePath()
          fill: color: "orange"
          outline: lineWidth: 10 lineJoin: :round
      test: (e) -> assert.eq e.drawArea, rect -5, -5, 110, 110

    renderTest
      "custom with area"
      render: -> Element
        size: 100
        drawOrder:
          shape:
            area: rect 20, 10, 20, 80
            path: (context, area) ->
              {top, left, right, bottom, vCenter, hCenter} = area
              context.moveTo  hCenter, top
              context.lineTo  right, bottom
              context.lineTo  left, bottom
              context.closePath()
          fill: :orange
      test: (e) -> assert.eq e.drawArea, rect 20, 10, 20, 80


    renderTest
      "custom with params"
      render: -> Element
        size: 100
        drawOrder:
          shape:
            area: rect 20, 10, 20, 80
            foo: 35
            path: (context, area, {foo}) ->
              {top, left, right, bottom, vCenter, hCenter} = area
              context.moveTo  hCenter, top
              context.lineTo  right, foo
              context.lineTo  left, bottom
              context.closePath()
          fill: :orange
      test: (e) -> assert.eq e.drawArea, rect 20, 10, 20, 80

  fill: ->
    renderTest
      "basic"
      render: -> Element
        size: 100
        drawOrder: "red"

    renderTest
      "rounded"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: 10
          color: "red"


  gradient: ->

    renderTest
      "double gradient is that easy"
      render: -> Element
        size: 100
        drawOrder:
          #f00 #f000
          #0f00 #0f0

    renderTest
      "gradient basic"
      render: -> Element
        size: 100
        drawOrder: color: :red :yellow

    renderTest
      "gradient to"
      render: -> Element
        size: 100
        drawOrder:
          color: :red :yellow
          to:   yh: 1
          from: xw: 1

    renderTest
      "gradient segments"
      render: -> Element
        size: 100
        drawOrder:
          0:  #f00
          .4: #ff0
          .5: #0f0
          .6: #0ff
          1:  #00f

  outline: ->
    renderTest
      "basic"
      render: -> Element
        size: 100
        drawOrder: outline: "red"
      test: (e) -> assert.eq e.drawArea, rect -.5, -.5, 101, 101

    renderTest
      "lineWidth"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: "red", lineWidth: 10
      test: (e) -> assert.eq e.drawArea, rect -5, -5, 110, 110

    renderTest
      "clipped"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: 10
          "clip"
          outline: color: "red", lineWidth: 10
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rounded"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: 10
          outline: color: "red"
      test: (e) -> assert.eq e.drawArea, rect -.5, -.5, 101, 101

  shadow: ->

    renderTest
      "fill drawArea"
      render: -> Element
        size: 100
        drawOrder:
          fill:
            color: "red"
            shadow: offset: 10
      test: (e) ->
        assert.eq e.drawArea, rect 115

    renderTest
      "fill padded"
      render: -> Element
        size: 100
        padding: 10
        drawOrder:
          fill:
            color: "red"
          {}
            padded: true
            fill:
              color: "red"
              shadow: true

    renderTest
      "outline drawArea"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: "red", lineWidth: 10, shadow: blur: 0, offset: 5
      test: (e) ->
        assert.eq e.drawArea, rect -5, -5, 116, 116

  clip: ->
    renderTest
      "clip"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: #0f0 lineWidth: 30
          "clip"
          outline: color: :red lineWidth: 10

    renderTest
      "clip children"
      render: -> Element
        size: 100
        drawOrder:
          "circle"
          "clip"
          "children"
          clip:     false
          outline:  lineWidth: 4

        RectangleElement color: "red"

    renderTest
      "clip: true/false"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: #0f0 lineWidth: 30
          {}
            clip: true
            outline: color: :red lineWidth: 10
          {}
            clip: false
            outline: color: #ff0a lineWidth: 20 compositeMode: :add

    renderTest
      "clip applies after shape"
      render: -> Element
        size: 100
        drawOrder:
          clip:     true
          rectangle: ({w, h}) -> rect -20, 0, w + 40, h
          "orange"
        RectangleElement color: "red"

      test: (e) ->
        assert.eq e.drawArea, rect -20, 0, 140, 100

    renderTest
      "drawOrder: clip: clips children"
      render: -> Element
        size: 100
        drawOrder:
          clip:       true
          rectangle:  ({w, h}) -> rect -20, 0, w + 40, h
          "orange"
        RectangleElement color: "red"
        RectangleElement
          location: 50
          size: 1000
          color: "blue"

      test: (e) ->
        assert.eq e.drawArea, rect -20, 0, 140, 100


  children: ->
    renderTest
      "custom order"
      render: -> Element
        size: 100
        drawOrder: child: :a
        TextElement align: .5 padding: 5 text: "hidden without drawOrder" size: ps: 1
        RectangleElement key: :a color: #ff7

    renderTest
      "fill first"
      render: -> Element
        size: 100
        drawOrder:
          fill: :#ff7
        TextElement align: .5 padding: 5 text: "no background without drawOrder" size: ps: 1

    renderTest
      "mixed"
      render: -> Element
        size: 100
        drawOrder:
          fill: #ff7
          :children
          :clip
          outline: color: #7f7a lineWidth: 40
        TextElement align: .5 padding: 5 text: "in the middle" size: ps: 1

  pokemon: ->

    renderTest
      "shadow not clipped, children clipped"
      render: -> Element
        size: 200
        drawOrder:
          :circle
          fill: color: :white shadow: offset: 10 blur 10
          :clip
          {}
            rectangle: ({w,h}) -> rect 0, 0, w, h / 2
            fill:     :red
            outline:  color: :black lineWidth: 6

          :circle
          clip: false
          outline: color: :black lineWidth: 6

          {}
            circle: ({w, h}) -> rect w * .35, h * .35, w * .30, h * .30
            fill:     :white
            outline:  color: :black lineWidth: 6

          {}
            circle: ({w, h}) -> rect w * .40, h * .40, w * .20, h * .20
            outline:  color: :black lineWidth: .5

      test: (e) -> assert.eq e.drawArea, rect -3, -3, 218, 218

  regressions: ->
    renderTest
      "custom area"
      render: -> Element
        size: 100
        drawOrder:
          "grey"
          shape:
            path: Paths.rectanglePath
            area: ({w, h}) ->
              u = 10
              rect -u, 0, w + 2 * u, u
          "orange"
      test: (e) -> assert.eq e.drawArea, rect -10, 0, 120, 100

    wedge = (context, size) ->
      {x, y, w, h} = size
      context.moveTo x + 0, y + h
      context.lineTo x + w, y + h
      context.lineTo x + w, y + 0
      context.closePath()

    triangleUp = (context, size) ->
      {x, y, w, h} = size
      context.moveTo x + w / 2, y + 0
      context.lineTo x + w,     y + h
      context.lineTo x + 0,     y + h
      context.closePath()

    wedgeArea = ({w, h}) -> rect 0, h / 3, w, h / 3
    cursorArea = ({w, h}, {pos}) ->
      unit = h / 4
      rect pos * w - unit, h - unit, 2 * unit, unit

    renderTest
      "wedge and cursor left"
      render: ->
        Element
          size: w: 200, h: 60
          drawOrder:
            shape:
              path: wedge
              area: wedgeArea
            "grey"
            shape:
              pos: 0
              area: cursorArea
              path: triangleUp
            "orange"

      test: (e) -> assert.eq e.drawArea, rect -15, 20, 215, 40

    renderTest
      "wedge and cursor middle"
      render: ->
        Element
          size: w: 200, h: 60
          drawOrder:
            shape:
              path: wedge
              area: wedgeArea
            "grey"
            shape:
              pos: .5
              area: cursorArea
              path: triangleUp
            "orange"

      test: (e) -> assert.eq e.drawArea, rect 0, 20, 200, 40


    renderTest
      "wedge and cursor right"
      render: ->
        Element
          size: w: 200, h: 60
          drawOrder:
            shape:
              path: wedge
              area: wedgeArea
            "grey"
            shape:
              pos: 1
              area: cursorArea
              path: triangleUp
            "orange"

      test: (e) -> assert.eq e.drawArea, rect 0, 20, 215, 40

    renderTest
      "add drawOrder updates drawArea"
      render: -> Element
        size: w: 200, h: 100
        Element
          size: ps: 1
          Element
            size: 50
            axis: .5
            location: ps: .5
            drawOrder: #0f0
      test: (e) ->
        [c] = e.children
        assert.eq e.drawArea, rect 75, 25, 50, 50
        assert.eq c.drawArea, rect 75, 25, 50, 50
        c.drawOrder = "red"
        e.toBitmapBasic()
        .then (bitmap) ->
          log {bitmap}
          assert.eq e.drawArea, rect 0, 0, 200, 100
          assert.eq c.drawArea, rect 0, 0, 200, 100

    renderTest
      "clip drawArea with textElement child"
      render: ->
        Element
          size: w: 50, h: 25
          key: :drawAreaElement
          clip: true
          TextElement
            key: :changeChild
            size: ps: 1
            text: "hi"
            color: #0ff
      test: (e) ->
        [dac] = e.find :drawAreaElement
        [cc] = e.find :changeChild
        assert.eq dac.drawArea, rect 20, 24
        cc.align = :topRight
        e.toBitmapBasic()
        .then (bitmap) ->
          log {bitmap}
          assert.eq
            dac.drawArea.roundOut()
            rect 29, 0, 21, 24
            "" should update drawArea
          assert.ok
            find el from bitmap.getImageDataArray :green
              el > 0
            "" expected text to draw somewhere

    renderTest
      "clip drawArea with drawOrder child"
      render: ->
        Element
          size: w: 50, h: 25
          key: :drawAreaElement
          clip: true
          Element
            key: :changeChild
            drawOrder:
              rect 20
              #0ff
      test: (e) ->
        [dac] = e.find :drawAreaElement
        [cc] = e.find :changeChild
        assert.eq dac.drawArea, rect 20
        cc.drawOrder =
          rectangle: rect 30, 0, 20, 20
          #0ff
        e.toBitmapBasic()
        .then (bitmap) ->
          log {bitmap}
          assert.eq
            dac.drawArea
            rect 30, 0, 20, 20
            "" should update drawArea
          assert.ok
            find el from bitmap.getImageDataArray :green
              el > 0
            "" expected child to draw somewhere
