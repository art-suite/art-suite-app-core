import &StandardImport

suite:
  shapes: ->
    renderTest
      "circle"
      render: -> Element
        size: 100
        drawOrder:
          "circle"
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: radius: 10"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: 10
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: radius: tl:20"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: tl: 20
          fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: ->"
      render: -> Element
        size: 100
        drawOrder:
          fill: color: "orange"
          {}
            rectangle: ({size}) -> rect size.div(4), size.div 2
            fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: rect()"
      render: -> Element
        size: 100
        drawOrder:
          fill: color: "orange"
          {}
            rectangle: rect 5, 5, 40, 40
            fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: area: ->"
      render: -> Element
        size: 100
        drawOrder:
          fill: color: "orange"
          {}
            rectangle:
              area: ({size}) -> rect size.div(4), size.div 2
              radius: 10
            fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rectangle: rect()"
      render: -> Element
        size: 100
        drawOrder:
          fill: color: "orange"
          {}
            rectangle:
              area: rect 5, 5, 40, 40
              radius: 10
            fill: color: "red"
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "custom with miter"
      render: -> Element
        size: 100
        drawOrder:
          shape: (context, area) ->
            {top, left, right, bottom, vCenter, hCenter} = area
            context.moveTo  hCenter, top
            context.lineTo  right, bottom
            context.lineTo  left, bottom
            context.closePath()
          fill: color: "orange"
          outline: lineWidth: 10
      test: (e) -> assert.eq e.drawArea, rect -15, -15, 130, 130

    renderTest
      "custom with miterLimit"
      render: -> Element
        size: 100
        drawOrder:
          shape: (context, area) ->
            {top, left, right, bottom, vCenter, hCenter} = area
            context.moveTo  hCenter, top
            context.lineTo  right, bottom
            context.lineTo  left, bottom
            context.closePath()
          fill: color: "orange"
          outline: lineWidth: 10 miterLimit: 2
      test: (e) -> assert.eq e.drawArea, rect -10, -10, 120, 120

    renderTest
      "custom with round"
      render: -> Element
        size: 100
        drawOrder:
          shape: (context, area) ->
            {top, left, right, bottom, vCenter, hCenter} = area
            context.moveTo  hCenter, top
            context.lineTo  right, bottom
            context.lineTo  left, bottom
            context.closePath()
          fill: color: "orange"
          outline: lineWidth: 10 lineJoin: :round
      test: (e) -> assert.eq e.drawArea, rect -5, -5, 110, 110

  fill: ->
    renderTest
      "basic"
      render: -> Element
        size: 100
        drawOrder: fill: "red"

    renderTest
      "gradient"
      render: -> Element
        size: 100
        drawOrder:
          fill: color: :red :yellow

    renderTest
      "gradient to"
      render: -> Element
        size: 100
        drawOrder:
          fill:
            color: :red :yellow
            to:   yh: 1
            from: xw: 1

    renderTest
      "rounded"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: 10
          fill: color: "red"

    renderTest
      "padded"
      render: -> Element
        size: 100
        padding: 10
        drawOrder: []
          {} fill: color: "red"
          {} padded: true fill: color: "orange"

  outline: ->
    renderTest
      "basic"
      render: -> Element
        size: 100
        drawOrder: outline: "red"
      test: (e) -> assert.eq e.drawArea, rect -1, -1, 102, 102

    renderTest
      "lineWidth"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: "red", lineWidth: 10
      test: (e) -> assert.eq e.drawArea, rect -5, -5, 110, 110

    renderTest
      "clipped"
      render: -> Element
        size: 100
        drawOrder:
          rectangle: radius: 10
          "clip"
          outline: color: "red", lineWidth: 10
      test: (e) -> assert.eq e.drawArea, rect 100

    renderTest
      "rounded"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: "red", radius: 10
      test: (e) -> assert.eq e.drawArea, rect -1, -1, 102, 102

  shadow: ->

    renderTest
      "fill drawArea"
      render: -> Element
        size: 100
        drawOrder:
          fill:
            color: "red"
            shadow: offset: 10
      test: (e) ->
        assert.eq e.drawArea, rect 115

    renderTest
      "fill padded"
      render: -> Element
        size: 100
        padding: 10
        drawOrder:
          fill:
            color: "red"
          {}
            padded: true
            fill:
              color: "red"
              shadow: true

    renderTest
      "outline drawArea"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: "red", lineWidth: 10, shadow: blur: 0, offset: 5
      test: (e) ->
        assert.eq e.drawArea, rect -5, -5, 116, 116

  clip: ->
    renderTest
      "clip"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: #0f0 lineWidth: 30
          "clip"
          outline: color: :red lineWidth: 10

    renderTest
      "clip children"
      render: -> Element
        size: 100
        drawOrder:
          "circle"
          "clip"
          "children"
          clip:     false
          outline:  lineWidth: 4

        RectangleElement color: "red"

    renderTest
      "clip: true/false"
      render: -> Element
        size: 100
        drawOrder:
          outline: color: #0f0 lineWidth: 30
          {}
            clip: true
            outline: color: :red lineWidth: 10
          {}
            clip: false
            outline: color: #ff0a lineWidth: 20 compositeMode: :add

  children: ->
    renderTest
      "custom order"
      render: -> Element
        size: 100
        drawOrder: child: :a
        TextElement align: .5 padding: 5 text: "hidden without drawOrder" size: ps: 1
        RectangleElement key: :a color: #ff7

    renderTest
      "fill first"
      render: -> Element
        size: 100
        drawOrder:
          fill: :#ff7
        TextElement align: .5 padding: 5 text: "no background without drawOrder" size: ps: 1

    renderTest
      "mixed"
      render: -> Element
        size: 100
        drawOrder:
          fill: #ff7
          :children
          :clip
          outline: color: #7f7a lineWidth: 40
        TextElement align: .5 padding: 5 text: "in the middle" size: ps: 1

  pokemon: ->

    renderTest
      "shadow not clipped, children clipped"
      render: -> Element
        size: 200
        drawOrder:
          :circle
          fill: color: :white shadow: offset: 10 blur 10
          :clip
          {}
            rectangle: ({size:{x,y}}) -> rect 0, 0, x, y / 2
            fill:     :red
            outline:  color: :black lineWidth: 6

          :circle
          clip: false
          outline: color: :black lineWidth: 6

          {}
            circle: ({size:{x,y}}) -> rect x * .35, y * .35, x * .30, y * .30
            fill:     :white
            outline:  color: :black lineWidth: 6

          {}
            circle: ({size:{x,y}}) -> rect x * .40, y * .40, x * .20, y * .20
            outline:  color: :black lineWidth: .5

      test: (e) -> assert.eq e.drawArea, rect -3, -3, 218, 218
