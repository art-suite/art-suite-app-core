"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "_resetArtSuiteModels", "Model", "assert", "models", "test", "chainedTest", "modelStore", "pending", "merge", "Promise", "missing"], [global, require('./StandardImport')], (describe, _resetArtSuiteModels, Model, assert, models, test, chainedTest, modelStore, pending, merge, Promise, missing) => {let reset; reset = function() {let MyModel; _resetArtSuiteModels(); MyModel = Caf.defClass(class MyModel extends Model {}); return assert.eq(true, !!models.myModel, {models});}; return describe({basic: function() {test("modelStore.reset & length", () => {reset(); return assert.eq(modelStore.length, 0);}); chainedTest("modelStore.update basic", () => {reset(); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {let modelRecord; assert.eq(modelStore.length, 1); assert.selectedEq({entryCount: 1, entrySubscribers: 1, modelCount: 1}, modelStore.status); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelRecord = modelStore.get("myModel", "myKey")); assert.isNumber(modelRecord.updatedAt); assert.isNumber(modelRecord.createdAt); return assert.lt(modelRecord.createdAt, modelRecord.updatedAt);});}).tapTest(["modelStoreEntry._getAndLogErrorMessage", () => {let logged, myLog, error, message; logged = []; myLog = (a) => logged.push(a); error = {}; message = modelStore._entriesByModelName.myModel.myKey._getAndLogErrorMessage(error, "giggle", myLog); assert.isString(message); assert.true(Caf.in("giggle", message)); return assert.eq(logged.length, 1);}], ["modelStore.inspectedObjects", () => {let inspectedObjects, myKey, createdAt, updatedAt; inspectedObjects = modelStore.inspectedObjects; myKey = inspectedObjects.myModel.myKey; createdAt = myKey.createdAt; updatedAt = myKey.updatedAt; assert.isNumber(createdAt); assert.isNumber(updatedAt); return assert.eq(inspectedObjects, {myModel: {myKey: {modelName: "myModel", key: "myKey", status: "pending", createdAt, updatedAt}}});}]); test("modelStore.update with no subscriber is noop", () => {reset(); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {assert.eq(modelStore.length, 0); return assert.eq(!!modelStore._getEntry("myModel", "myKey"), false);});}); test("modelStore.update twice replaces old value", () => {reset(); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); modelStore.update("myModel", "myKey", {baz: 2}); return modelStore.onNextReady(() => {assert.eq(modelStore.length, 1); return assert.selectedEq({status: pending, baz: 2, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey"));});}); test("modelStore.update with update function can merge", () => {reset(); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); modelStore.update("myModel", "myKey", (old) => merge(old, {baz: 2})); return modelStore.onNextReady(() => {assert.eq(modelStore.length, 1); return assert.selectedEq({status: pending, bar: 1, baz: 2, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey"));});}); test("modelStore.update cant set key", () => {reset(); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1, key: "boggle"}); return modelStore.onNextReady(() => {assert.doesNotExist(modelStore.get("myModel", "boggle")); return assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey"));});}); test("modelStore.update cant update key", () => {reset(); modelStore.subscribe("myModel", "myKey", () => {}); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {modelStore.update("myModel", "myKey", {bar: 1, key: "boggle2"}); return modelStore.onNextReady(() => assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelStore.get("myModel", "myKey")));});}); test("modelStore.subscribe basic", () => new Promise((resolve) => {reset(); modelStore.subscribe("myModel", "myKey", (modelRecord, previousModelRecord) => {assert.selectedEq({status: missing, key: "myKey", modelName: "myModel"}, previousModelRecord); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, modelRecord); return resolve();}); return modelStore.update("myModel", "myKey", {bar: 1});})); test("modelStore.unsubscribe", () => {let count1, count2, subscriber1, subscriber2; reset(); count1 = 0; count2 = 0; subscriber1 = (modelRecord) => count1++; subscriber2 = (modelRecord) => count2++; modelStore.subscribe("myModel", "myKey", subscriber1); modelStore.subscribe("myModel", "myKey", subscriber2); modelStore.update("myModel", "myKey", {bar: 1}); return modelStore.onNextReady(() => {assert.eq(count1, 1); assert.eq(count2, 1); modelStore.unsubscribe("myModel", "myKey", subscriber2); modelStore.update("myModel", "myKey", {bar: 2}); return modelStore.onNextReady(() => {assert.eq(count1, 2); return assert.eq(count2, 1);});});}); test("modelStore model callbacks: modelStoreEntryUpdated, modelStoreEntryAdded, modelStoreEntryRemoved", () => new Promise((resolve) => {let updateCount, addedCount, removedCount, MyModel2, mySubscription; reset(); updateCount = addedCount = removedCount = 0; MyModel2 = Caf.defClass(class MyModel2 extends Model {}, function(MyModel2, classSuper, instanceSuper) {this.prototype.modelStoreEntryUpdated = function(entry) {return updateCount++;}; this.prototype.modelStoreEntryAdded = function(entry) {return addedCount++;}; this.prototype.modelStoreEntryRemoved = function(entry) {assert.eq(2, updateCount); assert.eq(1, addedCount); assert.eq(1, ++removedCount); return resolve();};}); modelStore.subscribe("myModel2", "myKey", mySubscription = () => 123); return modelStore.onNextReady(() => modelStore.unsubscribe("myModel2", "myKey", mySubscription));})); test("subscribe triggers load on model", () => new Promise((resolve) => {let MyBasicModel; reset(); MyBasicModel = Caf.defClass(class MyBasicModel extends Model {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = resolve;}); return modelStore.subscribe("myBasicModel", "123", (modelRecord) => null);})); return test("subscribe with initial value does not trigger load on model nor subscription callback", () => {let MyBasicModel; reset(); MyBasicModel = Caf.defClass(class MyBasicModel extends Model {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key) {return assert.fail();};}); modelStore.subscribe("myBasicModel", "123", (modelRecord) => assert.fail(), {data: {foo: 1, bar: 2}}); return modelStore.onNextReady(() => {});});}});});});
//# sourceMappingURL=ModelStore.test.js.map
