"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "store", "ModelRegistry", "FluxModel", "assert", "models", "test", "chainedTest", "pending", "merge", "Promise", "missing"], [global, require('./StandardImport')], (describe, store, ModelRegistry, FluxModel, assert, models, test, chainedTest, pending, merge, Promise, missing) => {let reset; reset = function() {let MyModel; store._reset(); ModelRegistry._reset(); MyModel = Caf.defClass(class MyModel extends FluxModel {}); return assert.eq(true, !!models.myModel, {models});}; return describe({basic: function() {test("store.reset & length", () => {reset(); return assert.eq(store.length, 0);}); chainedTest("store.update basic", () => {reset(); store.subscribe("myModel", "myKey", () => {}); store.update("myModel", "myKey", {bar: 1}); return store.onNextReady(() => {let fluxRecord; assert.eq(store.length, 1); assert.selectedEq({entryCount: 1, entrySubscribers: 1, modelCount: 1}, store.status); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, fluxRecord = store.get("myModel", "myKey")); assert.isNumber(fluxRecord.updatedAt); assert.isNumber(fluxRecord.createdAt); return assert.lt(fluxRecord.createdAt, fluxRecord.updatedAt);});}).tapTest(["storeEntry._getAndLogErrorMessage", () => {let logged, myLog, error, message; logged = []; myLog = (a) => logged.push(a); error = {}; message = store._entriesByModelName.myModel.myKey._getAndLogErrorMessage(error, "giggle", myLog); assert.isString(message); assert.true(Caf.in("giggle", message)); return assert.eq(logged.length, 1);}], ["store.inspectedObjects", () => {let inspectedObjects, myKey, createdAt, updatedAt; inspectedObjects = store.inspectedObjects; myKey = inspectedObjects.myModel.myKey; createdAt = myKey.createdAt; updatedAt = myKey.updatedAt; assert.isNumber(createdAt); assert.isNumber(updatedAt); return assert.eq(inspectedObjects, {myModel: {myKey: {modelName: "myModel", key: "myKey", status: "pending", createdAt, updatedAt}}});}]); test("store.update with no subscriber is noop", () => {reset(); store.update("myModel", "myKey", {bar: 1}); return store.onNextReady(() => {assert.eq(store.length, 0); return assert.eq(!!store._getEntry("myModel", "myKey"), false);});}); test("store.update twice replaces old value", () => {reset(); store.subscribe("myModel", "myKey", () => {}); store.update("myModel", "myKey", {bar: 1}); store.update("myModel", "myKey", {baz: 2}); return store.onNextReady(() => {assert.eq(store.length, 1); return assert.selectedEq({status: pending, baz: 2, key: "myKey", modelName: "myModel"}, store.get("myModel", "myKey"));});}); test("store.update with update function can merge", () => {reset(); store.subscribe("myModel", "myKey", () => {}); store.update("myModel", "myKey", {bar: 1}); store.update("myModel", "myKey", (old) => merge(old, {baz: 2})); return store.onNextReady(() => {assert.eq(store.length, 1); return assert.selectedEq({status: pending, bar: 1, baz: 2, key: "myKey", modelName: "myModel"}, store.get("myModel", "myKey"));});}); test("store.update cant set key", () => {reset(); store.subscribe("myModel", "myKey", () => {}); store.update("myModel", "myKey", {bar: 1, key: "boggle"}); return store.onNextReady(() => {assert.doesNotExist(store.get("myModel", "boggle")); return assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, store.get("myModel", "myKey"));});}); test("store.update cant update key", () => {reset(); store.subscribe("myModel", "myKey", () => {}); store.update("myModel", "myKey", {bar: 1}); return store.onNextReady(() => {store.update("myModel", "myKey", {bar: 1, key: "boggle2"}); return store.onNextReady(() => assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, store.get("myModel", "myKey")));});}); test("store.subscribe basic", () => new Promise((resolve) => {reset(); store.subscribe("myModel", "myKey", (fluxRecord, previousFluxRecord) => {assert.selectedEq({status: missing, key: "myKey", modelName: "myModel"}, previousFluxRecord); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, fluxRecord); return resolve();}); return store.update("myModel", "myKey", {bar: 1});})); test("store.unsubscribe", () => {let count1, count2, subscriber1, subscriber2; reset(); count1 = 0; count2 = 0; subscriber1 = (fluxRecord) => count1++; subscriber2 = (fluxRecord) => count2++; store.subscribe("myModel", "myKey", subscriber1); store.subscribe("myModel", "myKey", subscriber2); store.update("myModel", "myKey", {bar: 1}); return store.onNextReady(() => {assert.eq(count1, 1); assert.eq(count2, 1); store.unsubscribe("myModel", "myKey", subscriber2); store.update("myModel", "myKey", {bar: 2}); return store.onNextReady(() => {assert.eq(count1, 2); return assert.eq(count2, 1);});});}); test("store model callbacks: storeEntryUpdated, storeEntryAdded, storeEntryRemoved", () => new Promise((resolve) => {let updateCount, addedCount, removedCount, MyModel2, mySubscription; reset(); updateCount = addedCount = removedCount = 0; MyModel2 = Caf.defClass(class MyModel2 extends FluxModel {}, function(MyModel2, classSuper, instanceSuper) {this.prototype.storeEntryUpdated = function(entry) {return updateCount++;}; this.prototype.storeEntryAdded = function(entry) {return addedCount++;}; this.prototype.storeEntryRemoved = function(entry) {assert.eq(2, updateCount); assert.eq(1, addedCount); assert.eq(1, ++removedCount); return resolve();};}); store.subscribe("myModel2", "myKey", mySubscription = () => 123); return store.onNextReady(() => store.unsubscribe("myModel2", "myKey", mySubscription));})); test("subscribe triggers load on model", () => new Promise((resolve) => {let MyBasicModel; reset(); MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = resolve;}); return store.subscribe("myBasicModel", "123", (fluxRecord) => null);})); return test("subscribe with initial value does not trigger load on model nor subscription callback", () => {let MyBasicModel; reset(); MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key) {return assert.fail();};}); store.subscribe("myBasicModel", "123", (fluxRecord) => assert.fail(), {data: {foo: 1, bar: 2}}); return store.onNextReady(() => {});});}});});});
//# sourceMappingURL=Store.test.js.map
