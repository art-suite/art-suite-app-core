"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "fluxStore", "ModelRegistry", "FluxModel", "assert", "models", "test", "pending", "merge", "Promise", "missing"], [global, require('./StandardImport')], (describe, fluxStore, ModelRegistry, FluxModel, assert, models, test, pending, merge, Promise, missing) => {let reset; reset = function() {let MyModel; fluxStore._reset(); ModelRegistry._reset(); MyModel = Caf.defClass(class MyModel extends FluxModel {}); return assert.eq(true, !!models.myModel, {models});}; return describe({basic: function() {test("fluxStore.reset & length", () => {reset(); return assert.eq(fluxStore.length, 0);}); test("fluxStore.update basic", () => {reset(); fluxStore.subscribe("myModel", "myKey", () => {}); fluxStore.update("myModel", "myKey", {bar: 1}); return fluxStore.onNextReady(() => {let fluxRecord; assert.eq(fluxStore.length, 1); assert.selectedEq({entryCount: 1, entrySubscribers: 1, modelCount: 1}, fluxStore.status); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, fluxRecord = fluxStore.get("myModel", "myKey")); assert.isNumber(fluxRecord.updatedAt); assert.isNumber(fluxRecord.createdAt); return assert.lt(fluxRecord.createdAt, fluxRecord.updatedAt);});}); test("fluxStore.update with no subscriber is noop", () => {reset(); fluxStore.update("myModel", "myKey", {bar: 1}); return fluxStore.onNextReady(() => {assert.eq(fluxStore.length, 0); return assert.eq(!!fluxStore._getEntry("myModel", "myKey"), false);});}); test("fluxStore.update twice replaces old value", () => {reset(); fluxStore.subscribe("myModel", "myKey", () => {}); fluxStore.update("myModel", "myKey", {bar: 1}); fluxStore.update("myModel", "myKey", {baz: 2}); return fluxStore.onNextReady(() => {assert.eq(fluxStore.length, 1); return assert.selectedEq({status: pending, baz: 2, key: "myKey", modelName: "myModel"}, fluxStore.get("myModel", "myKey"));});}); test("fluxStore.getHasSubscribers", () => {reset(); fluxStore.subscribe("myModel", "myKey", () => {}); assert.eq(false, fluxStore.getHasSubscribers("myModel", "myKey")); assert.eq(false, fluxStore.getHasSubscribers("myModel", "myKey")); return fluxStore.onNextReady(() => assert.eq(true, fluxStore.getHasSubscribers("myModel", "myKey")));}); test("fluxStore.update with update function can merge", () => {reset(); fluxStore.subscribe("myModel", "myKey", () => {}); fluxStore.update("myModel", "myKey", {bar: 1}); fluxStore.update("myModel", "myKey", (old) => merge(old, {baz: 2})); return fluxStore.onNextReady(() => {assert.eq(fluxStore.length, 1); return assert.selectedEq({status: pending, bar: 1, baz: 2, key: "myKey", modelName: "myModel"}, fluxStore.get("myModel", "myKey"));});}); test("fluxStore.update cant set key", () => {reset(); fluxStore.subscribe("myModel", "myKey", () => {}); fluxStore.update("myModel", "myKey", {bar: 1, key: "boggle"}); return fluxStore.onNextReady(() => {assert.doesNotExist(fluxStore.get("myModel", "boggle")); return assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, fluxStore.get("myModel", "myKey"));});}); test("fluxStore.update cant update key", () => {reset(); fluxStore.subscribe("myModel", "myKey", () => {}); fluxStore.update("myModel", "myKey", {bar: 1}); return fluxStore.onNextReady(() => {fluxStore.update("myModel", "myKey", {bar: 1, key: "boggle2"}); return fluxStore.onNextReady(() => assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, fluxStore.get("myModel", "myKey")));});}); test("fluxStore.subscribe basic", () => new Promise((resolve) => {reset(); fluxStore.subscribe("myModel", "myKey", (fluxRecord, previousFluxRecord) => {assert.selectedEq({status: missing, key: "myKey", modelName: "myModel"}, previousFluxRecord); assert.selectedEq({status: pending, bar: 1, key: "myKey", modelName: "myModel"}, fluxRecord); return resolve();}); return fluxStore.update("myModel", "myKey", {bar: 1});})); test("fluxStore.unsubscribe", () => {let count1, count2, subscriber1, subscriber2; reset(); count1 = 0; count2 = 0; subscriber1 = (fluxRecord) => count1++; subscriber2 = (fluxRecord) => count2++; fluxStore.subscribe("myModel", "myKey", subscriber1); fluxStore.subscribe("myModel", "myKey", subscriber2); fluxStore.update("myModel", "myKey", {bar: 1}); return fluxStore.onNextReady(() => {assert.eq(count1, 1); assert.eq(count2, 1); fluxStore.unsubscribe("myModel", "myKey", subscriber2); fluxStore.update("myModel", "myKey", {bar: 2}); return fluxStore.onNextReady(() => {assert.eq(count1, 2); return assert.eq(count2, 1);});});}); test("fluxStore model callbacks: fluxStoreEntryUpdated, fluxStoreEntryAdded, fluxStoreEntryRemoved", () => new Promise((resolve) => {let updateCount, addedCount, removedCount, MyModel2, mySubscription; reset(); updateCount = addedCount = removedCount = 0; MyModel2 = Caf.defClass(class MyModel2 extends FluxModel {}, function(MyModel2, classSuper, instanceSuper) {this.prototype.fluxStoreEntryUpdated = function(entry) {return updateCount++;}; this.prototype.fluxStoreEntryAdded = function(entry) {return addedCount++;}; this.prototype.fluxStoreEntryRemoved = function(entry) {assert.eq(2, updateCount); assert.eq(1, addedCount); assert.eq(1, ++removedCount); return resolve();};}); fluxStore.subscribe("myModel2", "myKey", mySubscription = () => 123); return fluxStore.onNextReady(() => fluxStore.unsubscribe("myModel2", "myKey", mySubscription));})); test("subscribe triggers load on model", () => new Promise((resolve) => {let MyBasicModel; reset(); MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = resolve;}); return fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => null);})); return test("subscribe with initial value does not trigger load on model nor subscription callback", () => {let MyBasicModel; reset(); MyBasicModel = Caf.defClass(class MyBasicModel extends FluxModel {}, function(MyBasicModel, classSuper, instanceSuper) {this.prototype.load = function(key) {return assert.fail();};}); fluxStore.subscribe("myBasicModel", "123", (fluxRecord) => assert.fail(), {data: {foo: 1, bar: 2}}); return fluxStore.onNextReady(() => {});});}});});});
//# sourceMappingURL=FluxStore.test.js.map
