// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, ErrorWithInfo, InstanceFunctionBindingMixin, Model, ModelRegistry, Promise, compactFlatten, decapitalize, defineModule, failure, formattedInspect, isFailure, isPlainObject, isString, log, merge, missing, pending, ref, ref1, store, success, validStatus,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require("art-standard-lib"), log = ref.log, decapitalize = ref.decapitalize, merge = ref.merge, isString = ref.isString, compactFlatten = ref.compactFlatten, Promise = ref.Promise, formattedInspect = ref.formattedInspect, isPlainObject = ref.isPlainObject, ErrorWithInfo = ref.ErrorWithInfo, defineModule = ref.defineModule;

  BaseObject = require('art-class-system').BaseObject;

  InstanceFunctionBindingMixin = require("@art-suite/instance-function-binding-mixin").InstanceFunctionBindingMixin;

  ref1 = require('art-communication-status'), missing = ref1.missing, success = ref1.success, pending = ref1.pending, failure = ref1.failure, validStatus = ref1.validStatus, isFailure = ref1.isFailure;

  store = require("./Store").store;

  ModelRegistry = require('./ModelRegistry');

  defineModule(module, Model = (function(superClass) {
    extend(Model, superClass);

    Model.abstractClass();

    Model.declarable({
      staleDataReloadSeconds: null,
      minNetworkFailureReloadSeconds: null,
      maxNetworkFailureReloadSeconds: 2e308,
      minServerFailureReloadSeconds: null,
      maxServerFailureReloadSeconds: 2e308
    });

    Model.getter({
      autoReloadEnabled: function() {
        return this.getStaleDataReloadSeconds() > 0 || this.getMinNetworkFailureReloadSeconds() > 0 || this.getMinServerFailureReloadSeconds() > 0;
      }
    });

    Model.register = function() {
      this.singletonClass();
      return ModelRegistry.register(this.getSingleton());
    };

    Model.postCreateConcreteClass = function(arg) {
      var hotReloaded;
      hotReloaded = arg.hotReloaded;
      if (hotReloaded) {
        this.singleton.bindFunctionsToInstance();
      } else {
        this.register();
      }
      return Model.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
    };


    /*
    INPUT: zero or more strings or arrays of strings
      - arbitrary nesting of arrays is OK
      - nulls are OK, they are ignored
    OUTPUT: null
    
    NOTE: @aliases can be called multiple times.
    
    example:
      class Post extends Model
        @aliases "chapterPost"
    
    purpose:
      - declare alternative names to access this model.
      - allows you to use the shortest form of FluxComponent subscriptions for each alias:
          @subscriptions "chapterPost"
        in addition to the model's class name:
          @subscriptions "post"
     */

    Model.aliases = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this._aliases = compactFlatten([args, this._aliases]);
      return null;
    };

    Model._aliases = [];

    Model.prototype.onNextReady = function(f) {
      return store.onNextReady(f);
    };

    function Model(name) {
      Model.__super__.constructor.apply(this, arguments);
      this._name = name || decapitalize(this["class"].getName());
      this.bindFunctionsToInstance();
      this._activeLoadingRequests = {};
    }

    Model.classGetter({
      models: function() {
        return ModelRegistry.models;
      },
      store: function() {
        return store;
      }
    });

    Model.getter({
      models: function() {
        return ModelRegistry.models;
      },
      store: function() {
        return store;
      },
      singlesModel: function() {
        return this._singlesModel || this;
      },
      storeEntries: function() {
        return store.getEntriesForModel(this.name);
      }
    });

    Model.prototype.subscribe = function(fluxKey, subscriptionFunction) {
      log.error("DEPRICATED - use FluxSubscriptionsMixin and it's subscribe");
      return store.subscribe(this._name, fluxKey, subscriptionFunction);
    };

    Model.getter("name", {
      modelName: function() {
        return this._name;
      }
    });


    /* load:
      load the requested data for the given key and update the store
    
      required:
        Should ALWAYS call store.update immediately OR once the data is available.
        Clients will assume that a call to "load" forces a reload of the data in the store.
    
      optional:
        If the data is immediately available, you can return the fluxRecord instead of "null"
        If load was called because of a new Component being mounted and its subscriptions initialized,
          returning the fluxRecord immediately will guarantee the Component has valid data for its
          first render.
    
      Note:
        Typically called automatically by the store when a Component subscribes to
        data from this model with the given key.
    
      The simplest possible load function:
        load: (key) -> @updateStore key, {}
    
      The "load" function below is:
        Simplest "load" with immediate fluxRecord return.
        Immediate return means:
        - store.subscribe() will return the fluxRecord returned from this "load"
        - FluxComponent subscriptions will update state in time for the inital render.
    
      inputs:
        key: string
    
      side effects:
        expected to call store.update @_name, key, fluxRecord
          - when fluxRecord.status is no longer pending
          - optionally as progress is made loading the fluxRecord.data
    
      returns: null OR fluxRecord if the value is immediately available
        NOTE: load can return null or fluxRecord as it chooses. The client shouldn't
          rely on the fact that it returned a fluxRecord with a set of inputs, it might not
          the next time.
    
      Optionally, you can implement one of two altenative load functions with Promise support:
    
        loadData:       (key) ->
                          promise.then (data) ->
                            if data is null or undefined, status will be set to missing
                            otherwise, status will be success
                          promise.catch (a validStatus or error info, status becomes failure) ->
        loadFluxRecord: (key) -> promise.then (fluxRecord) ->
    
        @load will take care of updating Store.
     */

    Model.prototype.load = function(key) {
      if (this.loadData || this.loadFluxRecord) {
        this.loadPromise(key);
        return null;
      } else {
        return this.updateStore(key, {
          status: missing
        });
      }
    };


    /* loadPromise:
      NOTE: @loadData or @loadFluxRecord should be implemented.
      @loadPromise is an alternative to @load
    
      Unlike @load, @loadPromise returns a promise that resolves when the load is done.
    
      The down-side is @loadPromise cannot immediately update the flux-store. If you have
      a model which stores its data locally, like ApplicationState, then override @load
      for immediate store updates.
    
      However, if your model always has to get the data asynchronously, override @loadData
      or @loadFluxRecord and use @loadPromise anytime you need to manually trigger a load.
    
      EFFECTS:
      - Triggers loadData or loadFluxRecord.
      - Puts the results in the store.
      - Elegently reduces multiple in-flight requests with the same key to one Promise.
        @loadData or @loadFluxRecord will only be invoked once per key while their
        returned promises are unresolved.
        NOTE: the block actually extends all the way through to the store being updated.
        That means you can immediately call @storeGet and get the latest data - when
        the promise resolves.
    
      OUT: promise.then (fluxRecord) ->
        fluxRecord: the latest, just-loaded data
        ERRORS: errors are encoded into the fluxRecord. The promise should always resolve.
     */

    Model.prototype.loadPromise = function(key) {
      var p;
      if (p = this._activeLoadingRequests[key]) {
        return p;
      }
      p = this.loadData ? Promise.then((function(_this) {
        return function() {
          return _this.loadingRecord(key);
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadData(key);
        };
      })(this)).then((function(_this) {
        return function(data) {
          return _this.updateStore(key, data != null ? {
            status: success,
            data: data
          } : {
            status: missing
          });
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          var info, ref2, status;
          status = validStatus(status = (error != null ? (ref2 = error.info) != null ? ref2.status : void 0 : void 0) || error) ? status : failure;
          info = error != null ? error.info : void 0;
          if (!(error instanceof Error)) {
            error = null;
          }
          return _this.updateStore(key, {
            status: status,
            info: info,
            error: error
          });
        };
      })(this)) : this.loadFluxRecord ? this.loadFluxRecord(key).then((function(_this) {
        return function(fluxRecord) {
          return _this.updateStore(key, fluxRecord);
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          return _this.updateStore(key, {
            status: failure,
            error: error
          });
        };
      })(this)) : Promise.resolve(this.updateStore(key, {
        status: missing
      }));
      return this._activeLoadingRequests[key] = p.then((function(_this) {
        return function(result) {
          _this.onNextReady();
          return result;
        };
      })(this)).then((function(_this) {
        return function(result) {
          _this._activeLoadingRequests[key] = null;
          return result;
        };
      })(this));
    };

    Model.prototype.reload = function(key) {
      if (this.loadData || this.loadFluxRecord) {
        return this.loadPromise(key);
      } else {
        return this.load(key);
      }
    };

    Model.prototype.loadingRecord = function(key) {
      var fluxRecord, ref2;
      if (isFailure((ref2 = (fluxRecord = this.storeGet(key))) != null ? ref2.status : void 0)) {
        return this.updateStore(key, merge(fluxRecord, {
          status: pending
        }));
      }
    };

    Model.prototype.storeGet = function(key) {
      return store.get(this._name, this.toKeyString(key));
    };

    Model.prototype.updateStore = function(key, fluxRecord) {
      return store.update(this._name, key, fluxRecord);
    };

    Model.prototype.onModelRegistered = function(modelName) {
      return ModelRegistry.onModelRegistered(modelName);
    };

    Model.prototype.get = function(key) {
      key = this.toKeyString(key);
      return Promise.then((function(_this) {
        return function() {
          var currentFluxRecord, ref2;
          if (((ref2 = (currentFluxRecord = _this.storeGet(key))) != null ? ref2.status : void 0) === pending) {
            currentFluxRecord = null;
          }
          return currentFluxRecord != null ? currentFluxRecord : _this.loadPromise(key);
        };
      })(this)).then(function(fluxRecord) {
        var data, status;
        status = fluxRecord.status, data = fluxRecord.data;
        if (status !== success) {
          throw new ErrorWithInfo("Model#get: Error getting data. Status: " + status + ".", {
            status: status,
            fluxRecord: fluxRecord
          });
        }
        return data;
      });
    };

    Model.prototype.toKeyString = function(key) {
      if (isPlainObject(key)) {
        return this.dataToKeyString(key);
      } else if (isString(key)) {
        return key;
      } else {
        throw new Error("Model " + this.name + ": Must implement custom toKeyString for non-string keys like: " + (formattedInspect(key)));
      }
    };

    Model.prototype.dataToKeyString = function(obj) {
      throw new Error("Model " + this.name + ": must override dataToKeyString for converting objects to key-strings.");
    };

    Model.getRecordPropsToKeyFunction = function(recordType) {
      return (function(_this) {
        return function(props, stateField) {
          var propsField, ref2, ref3;
          propsField = stateField != null ? stateField : recordType;
          return (ref2 = (ref3 = props[propsField]) != null ? ref3.id : void 0) != null ? ref2 : props[propsField + "Id"];
        };
      })(this);
    };

    Model.getter({
      propsToKey: function() {
        return this._propsToKey != null ? this._propsToKey : this._propsToKey = Model.getRecordPropsToKeyFunction(this.modelName);
      }
    });

    Model.prototype.storeEntryUpdated = function(entry) {};

    Model.prototype.storeEntryAdded = function(entry) {};

    Model.prototype.storeEntryRemoved = function(entry) {};

    Model.prototype._localStoreKey = function(id) {
      return "model:" + this._name + ":" + id;
    };

    Model.prototype._localStoreGet = function(id) {
      var data;
      if (data = localStorage.getItem(this._localStoreKey(id))) {
        return JSON.parse(data);
      } else {
        return null;
      }
    };

    Model.prototype._localStoreSet = function(id, data) {
      return localStorage.setItem(this._localStoreKey(id), JSON.stringify(data));
    };

    return Model;

  })(InstanceFunctionBindingMixin(BaseObject)));

}).call(this);

//# sourceMappingURL=Model.js.map
