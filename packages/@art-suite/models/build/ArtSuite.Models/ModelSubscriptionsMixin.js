// Generated by CoffeeScript 1.12.7
(function() {
  var ModelRegistry, defineModule, isFailure, isFunction, isPlainObject, isString, log, ref, ref1, rubyTrue, store, success,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), isString = ref.isString, defineModule = ref.defineModule, isPlainObject = ref.isPlainObject, rubyTrue = ref.rubyTrue, log = ref.log, isFunction = ref.isFunction;

  ref1 = require('art-communication-status'), success = ref1.success, isFailure = ref1.isFailure;

  store = require('./Store').store;

  ModelRegistry = require('./ModelRegistry');

  defineModule(module, function() {
    return function(superClass) {
      var ModelSubscriptionsMixin;
      return ModelSubscriptionsMixin = (function(superClass1) {
        var getRetryNow;

        extend(ModelSubscriptionsMixin, superClass1);

        function ModelSubscriptionsMixin() {
          ModelSubscriptionsMixin.__super__.constructor.apply(this, arguments);
          this._subscriptions = {};
        }

        ModelSubscriptionsMixin.getter({
          models: function() {
            return ModelRegistry.models;
          },
          subscriptions: function() {
            return this._subscriptions;
          }
        });


        /*
        subscribe OR update a subscription
        
        IN:
          subscriptionKey: string (REQUIRED - if no stateField OR modelName)
            Provide a unique key for each active subscription.
            To update the suscription, call @subscribe again with the same subscriptionKey.
            To unsubscribe, call @unsubscribe with the same subscriptionKey.
            DEFAULT: stateField || modelName
        
          modelName: lowerCamelCase string
            if modelName is null/undefined then
              - no subscription will be created.
              - @unsubscribe subscriptionKey will still happen
        
          key: valid input for models[modelName].toKeyString - usually it's a string
            if key is null/undefined then
              - no subscription will be created.
              - @unsubscribe subscriptionKey will still happen
        
          options:
             * if provided, will call @setState(stateField, ...) immediately and with every change
            stateField: string
        
            initialModelRecord: modelRecord-style object
        
             * get called with every change
            callback / updatesCallback:  (modelRecord) -> ignored
        
          NOTE: One of options.stateField OR options.updatesCallback is REQUIRED.
        
        OUT: existingModelRecord || initialModelRecord || status: missing modelRecord
        
        EFFECT:
          Establishes a Store subscription for the given model and modelKey.
          Upon any changes to the modelRecord, will:
            call updatesCallback, if provided
            and/or @setStateFromModelRecord if stateField was provided
        
          Will also call @setStateFromModelRecord immediately, if stateField is provided,
            with either the initialModelRecord, or the existing modelRecord, if any
        
          If there was already a subscription in this object with they same subscriptionKey,
          then @unsubscribe subscriptionKey will be called before setting up the new subscription.
        
          NOTE:
            updateCallback only gets called when modelRecord changes. It will not be called with the
            current value. HOWEVER, the current modelRecord is returned from the subscribe call.
        
            If you need to update anything based on the current value, use the return result.
         */

        ModelSubscriptionsMixin.prototype.subscribe = function(subscriptionKey, modelName, key, options) {
          var allOptions, callback, initialModelRecord, model, modelKey, stateField, subscriptionFunction, updatesCallback;
          if (isPlainObject(allOptions = subscriptionKey)) {
            subscriptionKey = allOptions.subscriptionKey, modelName = allOptions.modelName, key = allOptions.key, stateField = allOptions.stateField, initialModelRecord = allOptions.initialModelRecord, updatesCallback = allOptions.updatesCallback, callback = allOptions.callback;
            if (updatesCallback == null) {
              updatesCallback = callback;
            }
            if (subscriptionKey == null) {
              subscriptionKey = stateField || (modelName + " " + key);
            }
          } else {
            stateField = options.stateField, initialModelRecord = options.initialModelRecord, updatesCallback = options.updatesCallback;
          }
          if (!isString(subscriptionKey)) {
            throw new Error("REQUIRED: subscriptionKey");
          }
          if (!(isString(stateField) || isFunction(updatesCallback))) {
            throw new Error("REQUIRED: updatesCallback or stateField");
          }
          this.unsubscribe(subscriptionKey);
          if (!(rubyTrue(key) && modelName)) {
            return this.setStateFromModelRecord(stateField, initialModelRecord || {
              status: success
            }, null, key);
          }
          if (!(model = this.models[modelName])) {
            throw new Error("No model registered with the name: " + modelName + ". Registered models:\n  " + (Object.keys(this.models).join("\n  ")));
          }
          modelKey = model.toKeyString(key);
          subscriptionFunction = (function(_this) {
            return function(modelRecord) {
              if (typeof updatesCallback === "function") {
                updatesCallback(modelRecord);
              }
              return _this.setStateFromModelRecord(stateField, modelRecord, null, key);
            };
          })(this);
          this._subscriptions[subscriptionKey] = {
            modelName: modelName,
            modelKey: modelKey,
            subscriptionFunction: subscriptionFunction
          };
          return this.setStateFromModelRecord(stateField, store.subscribe(modelName, modelKey, subscriptionFunction, initialModelRecord), initialModelRecord, key);
        };


        /*
          IN: same as @subscribe
          OUT: promise.then -> # subscription has been created
          USE:
            Primarilly useful for models which want to subscribe to
            other models when they are constructed. This solves the
            loading-order problem.
         */

        ModelSubscriptionsMixin.prototype.subscribeOnModelRegistered = function(subscriptionKeyOrOptions, modelName, modelKey, options) {
          if (isPlainObject(subscriptionKeyOrOptions)) {
            modelName = subscriptionKeyOrOptions.modelName;
          }
          return ModelRegistry.onModelRegistered(modelName).then((function(_this) {
            return function() {
              return _this.subscribe(subscriptionKeyOrOptions, modelName, modelKey, options);
            };
          })(this));
        };

        ModelSubscriptionsMixin.prototype.unsubscribe = function(subscriptionKey) {
          var modelKey, modelName, subscription, subscriptionFunction;
          if (subscription = this._subscriptions[subscriptionKey]) {
            subscriptionFunction = subscription.subscriptionFunction, modelName = subscription.modelName, modelKey = subscription.modelKey;
            store.unsubscribe(modelName, modelKey, subscriptionFunction);
            delete this._subscriptions[subscriptionKey];
          }
          return null;
        };

        ModelSubscriptionsMixin.prototype.unsubscribeAll = function() {
          var __, ref2, subscriptionKey;
          ref2 = this._subscriptions;
          for (subscriptionKey in ref2) {
            __ = ref2[subscriptionKey];
            this.unsubscribe(subscriptionKey);
          }
          return null;
        };

        getRetryNow = function(modelName, key) {
          return function() {
            return store._getEntry(modelName, key).reload();
          };
        };

        ModelSubscriptionsMixin.prototype.setStateFromModelRecord = function(stateField, modelRecord, initialModelRecord, key) {
          var data, modelName, progress, ref2, ref3, ref4, reloadAt, status, tryCount;
          if ((modelRecord != null ? modelRecord.status : void 0) !== success && (initialModelRecord != null ? initialModelRecord.status : void 0) === success) {
            modelRecord = initialModelRecord;
          }
          if (stateField && isFunction(this.setState)) {
            if (modelRecord) {
              status = (ref2 = modelRecord.status) != null ? ref2 : null, progress = (ref3 = modelRecord.progress) != null ? ref3 : null, data = (ref4 = modelRecord.data) != null ? ref4 : null;
            }
            this.setState(stateField, data);
            this.setState(stateField + "Key", key != null ? key : modelRecord.key);
            this.setState(stateField + "Status", status);
            this.setState(stateField + "Progress", progress);
            this.setState(stateField + "FailureInfo", modelRecord && isFailure(status) ? ((reloadAt = modelRecord.reloadAt, tryCount = modelRecord.tryCount, modelName = modelRecord.modelName, key = modelRecord.key, modelRecord), {
              reloadAt: reloadAt,
              tryCount: tryCount,
              status: status,
              retryNow: getRetryNow(modelName, key)
            }) : null);
          }
          return modelRecord;
        };

        return ModelSubscriptionsMixin;

      })(superClass);
    };
  });

}).call(this);

//# sourceMappingURL=ModelSubscriptionsMixin.js.map
