// Generated by CoffeeScript 1.12.7
(function() {
  var EpochClass, FluxEntry, FluxStore, GlobalEpochCycle, ModelRegistry, defineModule, failure, inspect, isFunction, isString, log, max, min, missing, object, pending, pushIfNotPresent, ref, ref1, ref2, ref3, success, toSeconds,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), log = ref.log, pushIfNotPresent = ref.pushIfNotPresent, isFunction = ref.isFunction, isString = ref.isString, inspect = ref.inspect, object = ref.object, defineModule = ref.defineModule, min = ref.min, max = ref.max, toSeconds = ref.toSeconds;

  ref1 = require('art-communication-status'), success = ref1.success, pending = ref1.pending, missing = ref1.missing, failure = ref1.failure;

  EpochClass = require('art-epoched-state').EpochClass;

  FluxEntry = require('./FluxEntry');

  ModelRegistry = require('./ModelRegistry');

  defineModule(module, FluxStore = (function(superClass) {
    extend(FluxStore, superClass);

    FluxStore.singletonClass();

    function FluxStore() {
      FluxStore.__super__.constructor.apply(this, arguments);
      this._reset();
    }

    FluxStore.getter("length");

    FluxStore.prototype.get = function(modelName, key) {
      var ref2;
      return (ref2 = this._getEntry(modelName, key)) != null ? ref2.fluxRecord : void 0;
    };

    FluxStore.prototype.getSubscribers = function(modelName, key) {
      var ref2;
      return (ref2 = this._getEntry(modelName, key)) != null ? ref2.subscribers : void 0;
    };

    FluxStore.prototype.getHasSubscribers = function(modelName, key) {
      var ref2;
      return !!((ref2 = this._getEntry(modelName, key)) != null ? ref2.getHasSubscribers() : void 0);
    };

    FluxStore.prototype.getEntriesForModel = function(modelName) {
      return this._entriesByModelName[modelName];
    };


    /*
      subscribe to all changes to the fluxStore FluxEntry identified by modelName and Key.
    
      subscribers:
        are notified on all changes to the entry's:
          @fluxRecord object
          @subscribers list
        are NOT explicitly notified of when the entry is first added or removed
          However, when an entry is added, subscribers will be notified that a change happened.
          When an entry is removed, subscribers will be again notified, and the "subscribers" param will be [].
        See subscribeToStore for notifications about entries being added or removed
    
      inputs:
        modelName: string
        key: string
    
        subscriber: (fluxRecord, previousFluxRecord) -> null
          IN:
            fluxRecord: plain object; the current value for the fluxRecord
            previousFluxRecord: plain object; the last value for the fluxRecord
          GUARANTEES:
            1. !propsEq fluxRecord, previousFluxRecord
            2. only called once per change
    
        initialFluxRecord: if set, and the key is not in the store, this is used
          as the initial value instead of the calling "load" on the model.
    
      side effects:
        vivifies a new entry with fluxRecord = {status: pending} if one isn't present
        calls ModelRegistry[modelName].load key if vivification occured
        Notifies all subscribers.
    
      returns: current fluxRecord for the entry
     */

    FluxStore.prototype.subscribe = function(modelName, key, subscriber, initialFluxRecord) {
      this._queueChange({
        modelName: modelName,
        key: key,
        addSubscriber: subscriber
      });
      return this._vivifyAndLoadEntry(modelName, key, initialFluxRecord).fluxRecord;
    };


    /*
      inputs:
        modelName: string
        key: string
        subscriber: the exact same function (including closure) used to subscribe
    
      side effects:
        Notifies all subscribers.
    
      returns: null
     */

    FluxStore.prototype.unsubscribe = function(modelName, key, subscriber) {
      return this._queueChange({
        modelName: modelName,
        key: key,
        removeSubscriber: subscriber
      });
    };


    /*
    put updates or creates the record
    updateFunctionOrNewFluxRecord: can be:
      1) an arbitrary function: (oldFluxRecord) -> newFluxRecord
        oldFluxRecord will be null/undefined only if the record has not been created.
        do not alter oldFluxRecord
        must return a new Object or null/undefined (in which case an empty Object is created)
      2) a new Object to replace the existing object
    
    Notifies all subscribers.
    returns: updateFunctionOrNewFluxRecord
     */

    FluxStore.prototype.update = function(modelName, key, updateFunctionOrNewFluxRecord) {
      if (!isString(key)) {
        throw new Error("key must be a string. Inputs: " + (inspect({
          modelName: modelName,
          key: key
        })));
      }
      this._queueChange({
        modelName: modelName,
        key: key,
        updateFunction: isFunction(updateFunctionOrNewFluxRecord) ? updateFunctionOrNewFluxRecord : function(oldRecord) {
          return updateFunctionOrNewFluxRecord;
        }
      });
      return updateFunctionOrNewFluxRecord;
    };

    FluxStore.getter({
      status: function() {
        var entries, entry, entryCount, entrySubscribers, key, model, modelCount, nextReload, now, ref2, reloadsPending;
        entrySubscribers = 0;
        modelCount = 0;
        entryCount = 0;
        reloadsPending = 0;
        nextReload = 2e308;
        now = toSeconds();
        ref2 = this._entriesByModelName;
        for (model in ref2) {
          entries = ref2[model];
          modelCount++;
          for (key in entries) {
            entry = entries[key];
            entryCount++;
            entrySubscribers += entry.subscriberCount;
            if (entry.reloadAt > now) {
              reloadsPending++;
              nextReload = Math.ceil(min(nextReload, entry.reloadAt - now));
            }
          }
        }
        return {
          entryCount: entryCount,
          entrySubscribers: entrySubscribers,
          modelCount: modelCount,
          reloadsPending: reloadsPending,
          nextReload: nextReload
        };
      }
    });

    FluxStore.prototype.getEntriesByStatus = function(status) {
      var entry, entryMap, filteredEntries, key, modelName, out, ref2;
      out = {};
      ref2 = this._entriesByModelName;
      for (modelName in ref2) {
        entryMap = ref2[modelName];
        filteredEntries = (function() {
          var results;
          results = [];
          for (key in entryMap) {
            entry = entryMap[key];
            if (entry.status === status) {
              results.push(entry);
            }
          }
          return results;
        })();
        if (filteredEntries.length > 0) {
          out[modelName] = filteredEntries;
        }
      }
      return out;
    };

    FluxStore.prototype._reset = function() {
      this._length = 0;
      this._entriesByModelName = {};
      return this._addedEntries = [];
    };

    FluxStore.prototype._getEntriesForModelName = function(modelName) {
      var base;
      return (base = this._entriesByModelName)[modelName] != null ? base[modelName] : base[modelName] = {};
    };

    FluxStore.prototype._getEntry = function(modelName, key) {
      if (!isString(modelName)) {
        throw new Error("Expected 'modelName' to be a String. Inputs: " + (inspect({
          key: key,
          modelName: modelName
        })));
      }
      if (!isString(key)) {
        throw new Error("Expected 'key' to be a String. Inputs: " + (inspect({
          key: key,
          modelName: modelName
        })));
      }
      return this._getEntriesForModelName(modelName)[key];
    };

    FluxStore.prototype._addEntry = function(modelName, key) {
      var entry;
      this._length++;
      entry = this._getEntriesForModelName(modelName)[key] = new FluxEntry(modelName, key);
      pushIfNotPresent(this._addedEntries, entry);
      return entry;
    };

    FluxStore.prototype._removeEntry = function(entry) {
      this._length--;
      return delete this._getEntriesForModelName(entry.fluxRecord.modelName)[entry.fluxRecord.key];
    };


    /*
    Returns existing entry if there is one, otherwise it vivifies a "defaultFluxRecord" and starts the model.load.
    
    _vivifyAndLoadEntry solves the problem of two or more subscriptions starting in the same epoch
    on a new entry. Without this, we'd try to call "load" on the same model+key more than once.
    Ex: if we are loading remote images, loading the same remote image multiple times is a huge waste.
    
    returns: entry
     */

    FluxStore.prototype._vivifyAndLoadEntry = function(modelName, key, initialFluxRecord) {
      var data, entry, ref2, ref3;
      entry = this._getEntry(modelName, key);
      if (!entry) {
        entry = this._addEntry(modelName, key);
        if (!initialFluxRecord) {
          if (data = (ref2 = global.artFluxInit) != null ? (ref3 = ref2[modelName]) != null ? ref3[key] : void 0 : void 0) {
            initialFluxRecord = {
              status: success,
              data: data
            };
          }
        }
        if (initialFluxRecord) {
          entry.setFluxRecord(initialFluxRecord);
        } else {
          this._loadKeyWithRetriesWithExponentalFalloff(modelName, key, entry);
        }
      }
      return entry;
    };

    FluxStore.prototype._loadKeyWithRetriesWithExponentalFalloff = function(modelName, key, entry) {
      var e, fluxRecord, loadRetryCallback, message, model, retryDelay;
      retryDelay = 250;
      if (model = ModelRegistry.models[modelName]) {
        loadRetryCallback = (function(_this) {
          return function(loadInfo) {
            if (loadInfo.status !== pending && loadInfo.status !== success && loadInfo.status !== missing) {
              if (_this._getEntry(modelName, key)) {
                if (retryDelay < 60 * 1000) {
                  retryDelay *= 2;
                }
                return console.warn("FluxStore retry is disabled");
              } else {
                return log({
                  FluxStore_get_retry: {
                    model: modelName,
                    key: key,
                    status: loadInfo.status,
                    aborting: "no longer have subscribers"
                  }
                });
              }
            }
          };
        })(this);
        try {
          if (fluxRecord = model.load(key, loadRetryCallback)) {
            return entry.setFluxRecord(fluxRecord);
          }
        } catch (error) {
          e = error;
          message = "Error loading record from model '" + modelName + "' for key '" + key + "'. Error: " + e;
          console.error(message, e.stack);
          return entry.setFluxRecord({
            status: failure,
            errorObject: e,
            message: message
          });
        }
      } else {
        return console.warn("ArtFlux: there is no model registered with the name: " + modelName + ". FluxEntry for " + modelName + ":" + key + " will forever be status: pending.");
      }
    };

    FluxStore.prototype._vivifyEntry = function(modelName, key) {
      return this._getEntry(modelName, key) || this._addEntry(modelName, key);
    };

    FluxStore.prototype._queueChange = function(change) {
      var key, modelName;
      modelName = change.modelName, key = change.key;
      if (!isString(modelName)) {
        throw new Error("Expected 'modelName' to be a String. Inputs: " + (inspect({
          key: key,
          modelName: modelName
        })));
      }
      if (!isString(key)) {
        throw new Error("Expected 'key' to be a String. Inputs: " + (inspect({
          key: key,
          modelName: modelName
        })));
      }
      this.queueItem(change);
      return null;
    };

    FluxStore.prototype.processEpochItems = function(changes) {
      var addSubscriber, entry, i, j, k, key, l, len, len1, len2, len3, modelName, models, ref2, ref3, ref4, ref5, ref6, removeEntry, removeSubscriber, removedEntries, updateFunction, updatedEntries;
      updatedEntries = [];
      removedEntries = [];
      for (i = 0, len = changes.length; i < len; i++) {
        ref2 = changes[i], modelName = ref2.modelName, key = ref2.key, removeEntry = ref2.removeEntry, addSubscriber = ref2.addSubscriber, removeSubscriber = ref2.removeSubscriber, updateFunction = ref2.updateFunction;
        entry = this._vivifyEntry(modelName, key);
        if (updateFunction) {
          entry._updateFluxRecord(updateFunction);
        } else if (addSubscriber) {
          entry._subscribe(addSubscriber);
        } else if (removeSubscriber) {
          entry._unsubscribe(removeSubscriber);
        }
        pushIfNotPresent(updatedEntries, entry);
      }
      models = ModelRegistry.models;
      for (j = 0, len1 = updatedEntries.length; j < len1; j++) {
        entry = updatedEntries[j];
        if ((ref3 = models[entry.getModelName()]) != null) {
          ref3.fluxStoreEntryUpdated(entry);
        }
        entry._notifySubscribers();
        if (entry.subscribers.length === 0) {
          pushIfNotPresent(removedEntries, entry);
          this._removeEntry(entry);
        }
      }
      ref4 = this._addedEntries;
      for (k = 0, len2 = ref4.length; k < len2; k++) {
        entry = ref4[k];
        if ((ref5 = models[entry.getModelName()]) != null) {
          ref5.fluxStoreEntryAdded(entry);
        }
      }
      for (l = 0, len3 = removedEntries.length; l < len3; l++) {
        entry = removedEntries[l];
        if ((ref6 = models[entry.getModelName()]) != null) {
          ref6.fluxStoreEntryRemoved(entry);
        }
      }
      this._addedEntries = [];
      return null;
    };

    return FluxStore;

  })(EpochClass));

  if (GlobalEpochCycle = (ref2 = Neptune.Art.Engine) != null ? (ref3 = ref2.Core) != null ? ref3.GlobalEpochCycle : void 0 : void 0) {
    GlobalEpochCycle.singleton.includeFlux(FluxStore.singleton);
  }

}).call(this);

//# sourceMappingURL=FluxStore.js.map
