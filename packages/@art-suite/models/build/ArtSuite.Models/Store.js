"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["EpochClass", "hardDeprecatedFunctionsAsMap", "Neptune", "ModelRegistry", "toInspectedObjects", "Infinity", "toSeconds", "Math", "min", "validateInputs", "String", "isFunction", "FluxEntry", "success", "pushIfNotPresent"], [global, require('./StandardImport'), require('art-epoched-state'), require('./Lib'), {FluxEntry: require('./FluxEntry'), ModelRegistry: require('./ModelRegistry')}], (EpochClass, hardDeprecatedFunctionsAsMap, Neptune, ModelRegistry, toInspectedObjects, Infinity, toSeconds, Math, min, validateInputs, String, isFunction, FluxEntry, success, pushIfNotPresent) => {let Store; return Store = Caf.defClass(class Store extends EpochClass {constructor() {super(...arguments); this._reset();};}, function(Store, classSuper, instanceSuper) {let GlobalEpochCycle, base2, base3; this.singletonClass(); this.getter("length", {models: function() {return ModelRegistry.models;}, inspectedObjects: function() {return toInspectedObjects(this._entriesByModelName);}, status: function() {let entrySubscribers, modelCount, entryCount, reloadsPending, nextReload, now; entrySubscribers = 0; modelCount = 0; entryCount = 0; reloadsPending = 0; nextReload = Infinity; now = toSeconds(); Caf.each2(this._entriesByModelName, (entries) => {modelCount++; return Caf.each2(entries, (entry) => {entryCount++; entrySubscribers += entry.subscriberCount; return (entry.reloadAt > now) ? (reloadsPending++, nextReload = Math.ceil(min(nextReload, entry.reloadAt - now))) : undefined;});}); return {entryCount, entrySubscribers, modelCount, reloadsPending, nextReload};}}); this.prototype.get = function(modelName, key) {let base; return Caf.exists(base = this._getEntry(modelName, key)) && base.fluxRecord;}; this.prototype.getSubscribers = function(modelName, key) {let base; return Caf.exists(base = this._getEntry(modelName, key)) && base.subscribers;}; this.prototype.getEntriesForModel = function(modelName) {return this._entriesByModelName[modelName];}; this.getter(hardDeprecatedFunctionsAsMap("hasSubscribers")); this.prototype.subscribe = function(modelName, key, subscriber, initialFluxRecord) {this._queueChange({modelName, key, addSubscriber: subscriber}); return this._vivifyAndLoadEntry(modelName, key, initialFluxRecord).fluxRecord;}; this.prototype.unsubscribe = function(modelName, key, subscriber) {return this._queueChange({modelName, key, removeSubscriber: subscriber});}; this.prototype.update = function(modelName, key, updateFunctionOrNewFluxRecord) {validateInputs(Caf.is(key, String), "Key must be a string.", key); this._queueChange({modelName, key, updateFunction: isFunction(updateFunctionOrNewFluxRecord) ? updateFunctionOrNewFluxRecord : () => updateFunctionOrNewFluxRecord}); return updateFunctionOrNewFluxRecord;}; this.prototype._reset = function() {this._length = 0; this._entriesByModelName = {}; return this._addedEntries = [];}; this.prototype._getEntriesForModelName = function(modelName) {let temp, base; return ((temp = (base = this._entriesByModelName)[modelName]) != null ? temp : base[modelName] = {});}; this.prototype._getEntry = function(modelName, key) {validateInputs(this.models[modelName], "Expected valid modelName.", modelName); validateInputs(Caf.is(key, String), "Expected 'key' to be a String.", key); return this._getEntriesForModelName(modelName)[key];}; this.prototype._addEntry = function(modelName, key, initialFluxRecord) {let entry; this._length++; this._addedEntries.push(entry = this._getEntriesForModelName(modelName)[key] = new FluxEntry(modelName, key, initialFluxRecord)); return entry;}; this.prototype._removeEntry = function(entry) {this._length--; delete this._getEntriesForModelName(entry.fluxRecord.modelName)[entry.fluxRecord.key]; return entry;}; this.prototype._vivifyEntry = function(modelName, key) {let temp; return ((temp = this._getEntry(modelName, key)) != null ? temp : this._addEntry(modelName, key));}; this.prototype._vivifyAndLoadEntry = function(modelName, key, initialFluxRecord) {let temp; return ((temp = this._getEntry(modelName, key)) != null ? temp : this._createAndInitEntry(modelName, key, initialFluxRecord));}; this.prototype._getGlobalInitialFluxRecordForEntry = function(modelName, key) {let data, initialFluxRecord, base, temp, base1; return (data = Caf.exists(base = ((temp = global.artFluxInit) != null ? temp : global.artSuiteModelsInit)) && (Caf.exists(base1 = base[modelName]) && base1[key])) ? initialFluxRecord = {data, status: success} : undefined;}; this.prototype._createAndInitEntry = function(modelName, key, initialFluxRecord) {let entry; entry = this._addEntry(modelName, key, initialFluxRecord != null ? initialFluxRecord : initialFluxRecord = this._getGlobalInitialFluxRecordForEntry(modelName, key)); if (!initialFluxRecord) {entry.load();}; return entry;}; this.prototype._queueChange = function(change) {let modelName, key; modelName = change.modelName; key = change.key; validateInputs(this.models[modelName], "Expected 'modelName' to be a valid model name.", change); validateInputs(Caf.is(key, String), "Expected 'key' to be a String.", change); this.queueItem(change); return null;}; this.prototype.processEpochItems = function(changes) {let updatedEntries, removedEntries, from, into, to, i, from1, into1, to1, i1, from2, into2, to2, i2, from3, into3, to3, i3; updatedEntries = []; removedEntries = []; from = changes; into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let modelName, key, addSubscriber, removeSubscriber, updateFunction, entry; ({modelName, key, addSubscriber, removeSubscriber, updateFunction} = from[i]); pushIfNotPresent(updatedEntries, entry = this._vivifyEntry(modelName, key)); if (updateFunction) {entry._updateFluxRecord(updateFunction);} else {if (addSubscriber) {entry._subscribe(addSubscriber);} else {if (removeSubscriber) {entry._unsubscribe(removeSubscriber);};};}; i++;};}; into; from1 = updatedEntries; into1 = from1; if (from1 != null) {to1 = from1.length; i1 = 0; while (i1 < to1) {let entry; entry = from1[i1]; entry.updated(); if (entry.subscribers.length === 0) {pushIfNotPresent(removedEntries, this._removeEntry(entry));}; i1++;};}; into1; from2 = this._addedEntries; into2 = from2; if (from2 != null) {to2 = from2.length; i2 = 0; while (i2 < to2) {let entry; entry = from2[i2]; entry.added(); i2++;};}; into2; from3 = removedEntries; into3 = from3; if (from3 != null) {to3 = from3.length; i3 = 0; while (i3 < to3) {let entry; entry = from3[i3]; entry.removed(); i3++;};}; into3; this._addedEntries = []; return null;}; if (GlobalEpochCycle = Caf.exists(base2 = Neptune.Art.Engine) && (Caf.exists(base3 = base2.Core) && base3.GlobalEpochCycle)) {GlobalEpochCycle.singleton.includeFlux(Store.singleton);};});});});
//# sourceMappingURL=Store.js.map
