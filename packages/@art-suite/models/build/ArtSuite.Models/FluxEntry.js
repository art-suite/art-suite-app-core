"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "console", "formattedInspect", "propsEq", "toSeconds", "min", "Math", "Object", "Error", "pending", "timeoutAt", "floatEq", "isSuccess", "isFailure", "networkFailure", "serverFailure", "failure", "pushIfNotPresent", "removeFirstMatch", "models"], [global, require('./StandardImport'), require('./ModelRegistry')], (BaseObject, console, formattedInspect, propsEq, toSeconds, min, Math, Object, Error, pending, timeoutAt, floatEq, isSuccess, isFailure, networkFailure, serverFailure, failure, pushIfNotPresent, removeFirstMatch, models) => {let getFluxStore, retryExponent, FluxEntry; getFluxStore = function() {let _fluxStore; return _fluxStore != null ? _fluxStore : _fluxStore = require('./FluxStore').fluxStore;}; retryExponent = 2; return FluxEntry = Caf.defClass(class FluxEntry extends BaseObject {constructor(modelName, key) {super(...arguments); this._model = models[modelName]; this._autoReload = this._model.autoReloadEnabled; this._updatedAt = this._createdAt = toSeconds(); this._reloadAt = this._lastSuccessfulLoadAt = null; this._tryCount = 0; this._fluxRecord = {key, modelName, createdAt: this.createdAt, updatedAt: this.updatedAt, status: pending}; this._subscribers = []; this._previousFluxRecord = null;};}, function(FluxEntry, classSuper, instanceSuper) {let warnCantSetField, warnUnsettableFields, _memoryLeakFreeReloader; this.warnCantSetField = warnCantSetField = function(newFluxRecord, oldFluxRecord, field) {let newValue, oldValue; newValue = newFluxRecord[field]; oldValue = Caf.exists(oldFluxRecord) && oldFluxRecord[field]; return (newFluxRecord.hasOwnProperty(field) && newValue !== oldValue) ? console.warn(`${Caf.toString(FluxEntry.namespacePath)}: Ignoring attempt to update the key of the Entry. Do not attempt to update the '${Caf.toString(field)}' field. Attempted new value: ${Caf.toString(formattedInspect(newValue))}. Unchanged, old value: ${Caf.toString(formattedInspect(oldValue))}.`) : undefined;}; this.warnUnsettableFields = warnUnsettableFields = function(newFluxRecord, oldFluxRecord) {warnCantSetField(newFluxRecord, oldFluxRecord, "key"); return warnCantSetField(newFluxRecord, oldFluxRecord, "modelName");}; this.property("createdAt", "updatedAt", "reloadAt", "lastSuccessfulLoadAt", "tryCount"); this.getter("previousFluxRecord", "fluxRecord", "subscribers", "model", "autoReload"); this.getter({dataChanged: function() {let base, base1; return !propsEq(Caf.exists(base = this._fluxRecord) && base.data, Caf.exists(base1 = this._previousFluxRecord) && base1.data);}, fluxRecordChanged: function() {return !propsEq(this._fluxRecord, this._previousFluxRecord);}, subscriberCount: function() {return this._subscribers.length;}, key: function() {return this._fluxRecord.key;}, modelName: function() {return this._fluxRecord.modelName;}, status: function() {return this._fluxRecord.status;}, reloadAt: function() {return this._fluxRecord.reloadAt;}, age: function() {let now; now = toSeconds(); return {reload: now - this.reloadAt | 0, created: now - this.createdAt | 0, updated: now - this.updatedAt | 0, lastSuccessfulLoad: now - this.lastSuccessfulLoadAt | 0};}, nextNetworkFailureRetryDelay: function() {let m, temp; return (0 < (m = this.model.getMinNetworkFailureReloadSeconds())) ? min(m * Math.pow(((temp = this.tryCount) != null ? temp : 1), retryExponent), this.model.getMaxNetworkFailureReloadSeconds()) : undefined;}, nextServerFailureRetryDelay: function() {let m, temp; return (0 < (m = this.model.getMinServerFailureReloadSeconds())) ? min(m * Math.pow(((temp = this.tryCount) != null ? temp : 1), retryExponent), this.model.getMaxServerFailureReloadSeconds()) : undefined;}, plainStructure: function() {return {fluxRecord: this._fluxRecord, subscribers: this._subscribers};}, hasSubscribers: function() {return this._subscribers.length > 0;}}); this.setter({fluxRecord: function(newFluxRecord) {let oldFluxRecord, key, modelName, now, temp, temp1; if (!(Caf.is(newFluxRecord, Object))) {throw new Error("fluxRecord must be an object");}; warnUnsettableFields(newFluxRecord, oldFluxRecord = this._fluxRecord); temp = this._fluxRecord; key = temp.key; modelName = temp.modelName; this._fluxRecord = newFluxRecord; newFluxRecord.key = key; newFluxRecord.modelName = modelName; ((temp1 = newFluxRecord.status) != null ? temp1 : newFluxRecord.status = pending); newFluxRecord.createdAt = this._createdAt; newFluxRecord.updatedAt = this._updatedAt = now = toSeconds(); return this._autoReload ? this._updateAutoReloadFields() : undefined;}, reloadAt: function(reloadAt) {let delta, now, rangePerterbation, rangeMin, rangeMax, oldDelta; return (0 < reloadAt) ? (delta = reloadAt - (now = toSeconds()), rangePerterbation = (delta < 80) ? 1 : 15, rangeMin = delta - rangePerterbation, rangeMax = delta + rangePerterbation, !(this._reloadAt && (oldDelta = this._reloadAt - now) >= rangeMin && oldDelta <= rangeMax) ? _memoryLeakFreeReloader(this.modelName, this.key, this._reloadAt = reloadAt = now + rangeMin + (rangeMax - rangeMin) * Math.random()) : undefined, this._fluxRecord.reloadAt = this._reloadAt) : undefined;}}); this.prototype.reload = function() {return this.model.reload(this.key);}; _memoryLeakFreeReloader = function(modelName, key, reloadAt) {return timeoutAt(reloadAt, () => {let entry, base; return floatEq(reloadAt, entry = Caf.exists(base = getFluxStore()._getEntry(modelName, key)) && base.reloadAt) ? entry.reload() : undefined;});}; this.prototype._updateAutoReloadFields = function() {let reloadDelta; reloadDelta = isSuccess(this.status) ? (this.lastSuccessfulLoadAt = this._updatedAt, this.tryCount = 1, this.model.getStaleDataReloadSeconds()) : isFailure(this.status) ? (this.tryCount += 1, (() => {switch (this.status) {case networkFailure: return this.nextNetworkFailureRetryDelay; case serverFailure: case failure: return this.nextServerFailureRetryDelay;};})()) : undefined; this._fluxRecord.lastSuccessfulLoadAt = this.lastSuccessfulLoadAt; this._fluxRecord.tryCount = this.tryCount; return this.reloadAt = (reloadDelta > 0) ? this._updatedAt + reloadDelta : null;}; this.prototype._notifySubscribers = function() {return this._previousFluxRecord ? (Caf.each2(this._subscribers, (subscriber) => subscriber(this._fluxRecord, this._previousFluxRecord)), this._previousFluxRecord = null) : undefined;}; this.prototype._updateFluxRecord = function(updateFunction) {let temp; ((temp = this._previousFluxRecord) != null ? temp : this._previousFluxRecord = this._fluxRecord); this.setFluxRecord(Caf.isF(updateFunction) && updateFunction(this._fluxRecord) || {}); return propsEq(this._fluxRecord, this._previousFluxRecord) ? this._previousFluxRecord = null : undefined;}; this.prototype._subscribe = function(subscriber) {return pushIfNotPresent(this._subscribers, subscriber);}; this.prototype._unsubscribe = function(subscriber) {return removeFirstMatch(this._subscribers, subscriber);};});});});
//# sourceMappingURL=FluxEntry.js.map
