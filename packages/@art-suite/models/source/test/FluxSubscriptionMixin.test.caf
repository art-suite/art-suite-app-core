import &StandardImport, {} &ApplicationState

describe
  subscribeOnModelRegistered: ->
    beforeEach _reset
    afterEach -> fluxStore.onNextReady()

    test "subscribeOnModelRegistered", ->
      new Promise (resolve, reject) ->
        class MyModelB extends FluxModel

        class MyModelA extends FluxSubscriptionsMixin FluxModel
          constructor: ->
            super
            @subscribeOnModelRegistered :mySubscriptionKey :myModelB :myFluxKey updatesCallback: ->
            .then resolve, reject

  "subscribe and initialFluxRecord": ->

    chainedTest "with stateField and initialFluxRecord", ->
      _reset()
      class MyModel extends &ApplicationState

      new class MyObject extends FluxSubscriptionsMixin BaseObject

        constructor: ->
          @subscribe :mySubscriptionKey :myModel :myFluxKey,
            initialFluxRecord: data: :myInitialData
            stateField: :myStateField

      assert.selectedEq
        status:       pending
        data:         :myInitialData
        key:          :myFluxKey
        modelName:    :myModel
        fluxStore.get :myModel :myFluxKey

      fluxStore.onNextReady()

    # .thenTest "still pending?" ->
    #   assert.selectedEq
    #     status:       success
    #     data:         :myInitialData
    #     key:          :myFluxKey
    #     modelName:    :myModel
    #     fluxStore.get :myModel :myFluxKey

    test "with stateField and no initialFluxRecord", ->
      _reset()
      class MyModel extends &ApplicationState

      new class MyObject extends FluxSubscriptionsMixin BaseObject

        constructor: ->
          @subscribe "mySubscriptionKey", "myModel", "myFluxKey",
            stateField: "myStateField"

      assert.selectedEq
        status:     missing
        key:        "myFluxKey"
        modelName:  "myModel"
        fluxStore.get "myModel", "myFluxKey"
