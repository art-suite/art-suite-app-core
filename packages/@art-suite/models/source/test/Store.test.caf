import &StandardImport

reset = ->
  store._reset()
  ModelRegistry._reset()
  class MyModel extends FluxModel
  assert.eq true, !!models.myModel,{models}

describe basic: ->
  test "store.reset & length", ->
    reset()
    assert.eq store.length, 0

  chainedTest "store.update basic", ->
    reset()
    store.subscribe "myModel", "myKey", -> # required to make the record persist
    store.update "myModel", "myKey", bar:1

    store.onNextReady ->
      assert.eq store.length, 1
      assert.selectedEq
        entryCount:       1
        entrySubscribers: 1
        modelCount:       1
        store.status

      assert.selectedEq
        status: pending, bar: 1 key: :myKey modelName: :myModel
        fluxRecord = store.get :myModel :myKey

      assert.isNumber fluxRecord.updatedAt
      assert.isNumber fluxRecord.createdAt
      assert.lt fluxRecord.createdAt, fluxRecord.updatedAt

  .tapTest
    "storeEntry._getAndLogErrorMessage" ->
      logged = []
      myLog = (a) -> logged.push a
      error = {}
      message = store._entriesByModelName.myModel.myKey._getAndLogErrorMessage error, :giggle myLog
      assert.isString message
      assert.true :giggle in message
      assert.eq logged.length, 1

    "store.inspectedObjects" ->
      store extract inspectedObjects extract myModel.myKey extract createdAt, updatedAt
      assert.isNumber createdAt
      assert.isNumber updatedAt
      assert.eq
        inspectedObjects
        myModel:
          myKey: {}
            modelName: :myModel
            key:       :myKey
            status:    :pending
            createdAt
            updatedAt

  test "store.update with no subscriber is noop", ->
    reset()
    store.update "myModel", "myKey", bar:1

    store.onNextReady ->
      assert.eq store.length, 0
      assert.eq !!store._getEntry("myModel", "myKey"), false

  test "store.update twice replaces old value", ->
    reset()
    store.subscribe "myModel", "myKey", -> # required to make the record persist
    store.update "myModel", "myKey", bar:1
    store.update "myModel", "myKey", baz:2

    store.onNextReady ->
      assert.eq store.length, 1
      assert.selectedEq
        status: pending, baz: 2, key: "myKey", modelName: "myModel"
        store.get "myModel", "myKey"

  # test "store.getHasSubscribers", ->
  #   reset()
  #   store.subscribe "myModel", "myKey", -> # required to make the record persist
  #   assert.eq false, store.getHasSubscribers "myModel", "myKey"
  #   assert.eq false, store.getHasSubscribers "myModel", "myKey"

  #   store.onNextReady ->
  #     assert.eq true, store.getHasSubscribers "myModel", "myKey"

  test "store.update with update function can merge", ->
    reset()
    store.subscribe "myModel", "myKey", -> # required to make the record persist
    store.update "myModel", "myKey", bar:1
    store.update "myModel", "myKey", (old) -> merge old, baz:2

    store.onNextReady ->
      assert.eq store.length, 1
      assert.selectedEq
        status: pending, bar:1, baz: 2, key: "myKey", modelName: "myModel"
        store.get "myModel", "myKey"

  test "store.update cant set key", ->
    reset()
    store.subscribe :myModel :myKey -> # required to make the record persist
    store.update    :myModel :myKey bar: 1 key: :boggle

    store.onNextReady ->
      assert.doesNotExist store.get :myModel :boggle
      assert.selectedEq
        status: pending, bar: 1 key: :myKey modelName: :myModel
        store.get :myModel :myKey

  test "store.update cant update key", ->
    reset()
    store.subscribe "myModel", "myKey", -> # required to make the record persist
    store.update "myModel", "myKey", bar:1

    store.onNextReady ->
      store.update "myModel", "myKey", bar:1, key: "boggle2"

      store.onNextReady ->
        assert.selectedEq
          status: pending, bar: 1, key: "myKey", modelName: "myModel"
          store.get "myModel", "myKey"

  test "store.subscribe basic", ->
    new Promise (resolve) ->

      reset()

      store.subscribe "myModel", "myKey", (fluxRecord, previousFluxRecord) ->
        assert.selectedEq
          status: missing, key: "myKey", modelName: "myModel"
          previousFluxRecord

        assert.selectedEq
          status: pending, bar: 1, key: "myKey", modelName: "myModel"
          fluxRecord
        resolve()

      store.update "myModel", "myKey", bar: 1

  test "store.unsubscribe", ->
    reset()
    count1 = 0
    count2 = 0
    subscriber1 = (fluxRecord) -> count1++
    subscriber2 = (fluxRecord) -> count2++

    store.subscribe "myModel", "myKey", subscriber1
    store.subscribe "myModel", "myKey", subscriber2
    store.update "myModel", "myKey", bar: 1
    store.onNextReady ->
      assert.eq count1, 1
      assert.eq count2, 1
      store.unsubscribe "myModel", "myKey", subscriber2
      store.update "myModel", "myKey", bar: 2
      store.onNextReady ->
        assert.eq count1, 2
        assert.eq count2, 1


  test "store model callbacks: storeEntryUpdated, storeEntryAdded, storeEntryRemoved", ->
    new Promise (resolve) ->
      reset()
      updateCount = addedCount = removedCount = 0
      class MyModel2 extends FluxModel
        storeEntryUpdated:  (entry) -> updateCount++
        storeEntryAdded:    (entry) -> addedCount++
        storeEntryRemoved:  (entry) ->
          assert.eq 2, updateCount
          assert.eq 1, addedCount
          assert.eq 1, ++removedCount
          resolve()

      store.subscribe "myModel2", "myKey", mySubscription = -> 123
      store.onNextReady ->
        store.unsubscribe "myModel2", "myKey", mySubscription

  test "subscribe triggers load on model", ->
    new Promise (resolve) ->
      reset()
      class MyBasicModel extends FluxModel
        load: resolve

      store.subscribe :myBasicModel :123 (fluxRecord) -> null

  test "subscribe with initial value does not trigger load on model nor subscription callback", ->
    reset()
    class MyBasicModel extends FluxModel
      load: (key) -> assert.fail()

    store.subscribe
      :myBasicModel
      :123
      (fluxRecord) -> assert.fail()
      data: foo: 1 bar: 2

    store.onNextReady ->
