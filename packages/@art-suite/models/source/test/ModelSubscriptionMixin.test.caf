import &StandardImport, {} &ApplicationState

describe
  subscribeOnModelRegistered: ->
    beforeEach _resetArtSuiteModels
    afterEach -> modelStore.onNextReady()

    test "subscribeOnModelRegistered", ->
      new Promise (resolve, reject) ->
        class MyModelB extends Model

        class MyModelA extends ModelSubscriptionsMixin Model
          constructor: ->
            super
            @subscribeOnModelRegistered :mySubscriptionKey :myModelB :myModelKey updatesCallback: ->
            .then resolve, reject

  "subscribe and initialModelRecord": ->

    chainedTest "with stateField and initialModelRecord", -> _resetArtSuiteModels().then ->
      class MyModel extends &ApplicationState

      new class MyObject extends ModelSubscriptionsMixin BaseObject

        constructor: ->
          @subscribe :mySubscriptionKey :myModel :myModelKey,
            initialModelRecord: data: :myInitialData
            stateField: :myStateField

      assert.selectedEq
        status:       pending
        data:         :myInitialData
        key:          :myModelKey
        modelName:    :myModel
        modelStore.get :myModel :myModelKey

      modelStore.onNextReady()

    # .thenTest "still pending?" ->
    #   assert.selectedEq
    #     status:       success
    #     data:         :myInitialData
    #     key:          :myModelKey
    #     modelName:    :myModel
    #     modelStore.get :myModel :myModelKey

    test "with stateField and no initialModelRecord", -> _resetArtSuiteModels().then ->
      class MyModel extends &ApplicationState

      new class MyObject extends ModelSubscriptionsMixin BaseObject

        constructor: ->
          @subscribe "mySubscriptionKey", "myModel", "myModelKey",
            stateField: "myStateField"

      assert.selectedEq
        status:     missing
        key:        "myModelKey"
        modelName:  "myModel"
        modelStore.get "myModel", "myModelKey"
