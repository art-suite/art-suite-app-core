import &StandardImport, {} &ApplicationState

describe
  subscribe: ->
    beforeEach _reset
    test "with modelName and stateField", -> new Promise (resolve, reject) ->
      class MyModel extends ApplicationState

      myObject = new class MyObject extends ModelSubscriptionsMixin BaseObject

        setState: (key, value) ->
          resolve() if key == "myStateField" && value == "hi"

        constructor: ->
          @subscribe "mySubscriptionKey", "myModel", "myFluxKey", stateField: "myStateField"

      assert.hasKeys myObject.subscriptions

      timeout()
      .then -> models.myModel.setState "myFluxKey", "hi"

    test "with fluxKey = null means dont subscribe", ->
      class MyModel extends ApplicationState

      myObject = new class MyObject extends ModelSubscriptionsMixin BaseObject

        constructor: ->
          @subscribe :mySubscriptionKey :myModel null stateField: :myStateField

      assert.hasNoKeys myObject.subscriptions

  change: ->
    beforeEach _reset

    test "change subscription", -> new Promise (resolve, reject) ->
      class MyModel extends ApplicationState

      myObject = new class MyObject extends ModelSubscriptionsMixin BaseObject

        setState: (key, value) ->
          if key == "myStateField" && value
            if value == "hi"
              resolve()
            else
              reject wrongSetState: {key, value}

        constructor: ->
          @subscribe "mySubscriptionKey", "myModel", "myFluxKey", stateField: "myStateField"

      timeout()
      .then ->
        # change the subscription
        myObject.subscribe "mySubscriptionKey", "myModel", "myFluxKey2", stateField: "myStateField"

      .then ->
        # should be ignored if properly not listening to old key
        models.myModel.setState "myFluxKey", "oops, still listening to old key"

        # should trigger updates, if properly listening to new key
        models.myModel.setState "myFluxKey2", "hi"

  unsubscribe: ->
    beforeEach _reset

    test "unsubscribe", -> new Promise (resolve, reject) ->
      class MyModel extends ApplicationState

      myObject = new class MyObject extends ModelSubscriptionsMixin BaseObject

        setState: (key, value) ->
          if key == "myStateField" && value
            if value == "hi"
              resolve()
            else
              log "reject"
              reject wrongSetState: {key, value}

        constructor: ->
          @subscribe "mySubscriptionKey", "myModel", "myFluxKey", stateField: "myStateField"

      timeout()
      .then ->
        # comment this out and test should fail
        myObject.unsubscribe "mySubscriptionKey"

        # should be ignored if properly not listening to old key
        models.myModel.setState "myFluxKey", "oops, still listening to old key"

        timeout 10 # not the best method to give the setState-reject a chance to fire before resolving, can anyone think of a better way?

      .then resolve

    test "unsubscribeAll", -> new Promise (resolve, reject) ->
      class MyModel extends ApplicationState

      myObject = new class MyObject extends ModelSubscriptionsMixin BaseObject

        setState: (key, value) ->
          if key == "myStateField" && value
            if value == "hi"
              resolve()
            else
              log "reject"
              reject wrongSetState: {key, value}

        constructor: ->
          @subscribe "mySubscriptionKey", "myModel", "myFluxKey", stateField: "myStateField"

      timeout()
      .then ->
        # comment this out and test should fail
        myObject.unsubscribeAll()

        # should be ignored if properly not listening to old key
        models.myModel.setState "myFluxKey", "oops, still listening to old key"

        timeout 10 # not the best method to give the setState-reject a chance to fire before resolving, can anyone think of a better way?

      .then resolve
