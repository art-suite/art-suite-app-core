import &StandardImport, &ModelRegistry, &Lib

getStore = -> _store ?= &Store.store

retryExponent = 2

class FluxEntry extends BaseObject
  # assumes FluxEntry "owns" the fluxRecord - it will alter the object by adding a "key" field
  constructor: (modelName, key, initialFluxRecord = {}) ->
    @_model       = models[modelName]
    @_autoReload  = @_model.autoReloadEnabled

    @_currentPendingReload = null

    initialFluxRecord.key ?= key
    initialFluxRecord.modelName ?= modelName
    @setFluxRecord initialFluxRecord

    @_subscribers = []
    @_previousFluxRecord = null

  @getter :previousFluxRecord :fluxRecord :subscribers :model :autoReload
  @getter
    subscriberCount:    -> @_subscribers.length
    key:                -> @_fluxRecord.key
    modelName:          -> @_fluxRecord.modelName
    status:             -> @_fluxRecord.status
    inspectedObjects:   -> merge {}
      @modelName, @key, @status
      @createdAt, @updatedAt, @reloadAt
      @fluxRecord.data, @fluxRecord.message, @fluxRecord.error

    nextNetworkFailureRetryDelay: ->
      if 0 < m = @model.getMinNetworkFailureReloadSeconds()
        min
          m * Math.pow @tryCount ? 1, retryExponent
          @model.getMaxNetworkFailureReloadSeconds()

    nextServerFailureRetryDelay: ->
      if 0 < m = @model.getMinServerFailureReloadSeconds()
        min
          m * Math.pow @tryCount ? 1, retryExponent
          @model.getMaxServerFailureReloadSeconds()

  @getter hardDeprecatedFunctionsAsMap :dataChanged :fluxRecordChanged :age :plainStructure :hasSubscribers

  each fluxRecordSetter in :tryCount :reloadAt :updatedAt :createdAt
    @getter [fluxRecordSetter]: -> @_fluxRecord[fluxRecordSetter]
    @setter [fluxRecordSetter]: (v) -> @_fluxRecord[fluxRecordSetter] = v

  @setter
    fluxRecord: (newFluxRecord)->
      validateInputs newFluxRecord is Object, "New fluxRecord must be an object.", newFluxRecord

      (@_fluxRecord ? newFluxRecord) extract key, modelName, createdAt
      @_fluxRecord = newFluxRecord
      newFluxRecord.key       =   key
      newFluxRecord.modelName =   modelName
      newFluxRecord.status    ?=  pending
      newFluxRecord.updatedAt =   now = toSeconds()
      newFluxRecord.createdAt =   createdAt ? now

      @_updateAutoReloadFields() if @_autoReload

  # IN: reloadDelta: number greater than 0 miliseconds, OR ignore this call and don't schedule reload
  scheduleReload: (reloadDelta) -> if reloadDelta > 0
    reloadAt = @updatedAt + reloadDelta
    delta = max 1, reloadAt - now = toSeconds()
    rangePerterbation = if delta < 80 then 1 else 15
    rangeMin = delta - rangePerterbation
    rangeMax = delta + rangePerterbation

    # check if we already have a reload scheduled sooner than rangeMax
    unless @reloadAt < now + rangeMax

      # schedule reloadAt between rangeMin and range Max (random pertubation so reloads are distributed)
      @reloadAt = now + rangeMin + (rangeMax - rangeMin) * Math.random()
      @ extract modelName, key
      @_currentPendingReload = thisPendingReload = timeoutAt @reloadAt, ~>
        entry = getStore()._getEntry modelName, key
        if thisPendingReload == entry?._currentPendingReload
          entry._resetAutoReload()
          entry.reload()

  reload: -> @model.reload @key

  load: ->
    try
      @setFluxRecord fluxRecord if fluxRecord = @model.load @key

    catch error
      @setFluxRecord {}
        error, status: failure
        message: @_getAndLogErrorMessage error, :loading

    @

  # added, removed and updated are triggered by Store during the Epoch update
  added:    -> @model.storeEntryAdded @
  removed:  -> @model.storeEntryRemoved @
  updated:  ->
    @model.storeEntryUpdated @
    @_notifySubscribers()

  ##########################
    PRIVATE
  ##########################
  _resetAutoReload: -> @_currentPendingReload = @reloadAt = null; @tryCount = 0

  _updateAutoReloadFields: ->
    if isSuccess @status
      @tryCount = 1
      @scheduleReload @model.getStaleDataReloadSeconds()

    else if isFailure @status
      @tryCount += 1
      switch @status
        when networkFailure         then @scheduleReload @nextNetworkFailureRetryDelay
        when serverFailure, failure then @scheduleReload @nextServerFailureRetryDelay

  # OUT: message generated
  _getAndLogErrorMessage: (error, failedAction, _log = log.error) ->
    _log {} error, message = "" Error #{failedAction} Entry for model: #{@modelName}, key: #{formattedInspect @key}
    message

  _updateFluxRecord: (updateFunction) ->
    @_previousFluxRecord ?= @_fluxRecord
    try @setFluxRecord updateFunction?(@_fluxRecord) || {}
    catch error
      @_getAndLogErrorMessage error, :updating

    @_previousFluxRecord = null if propsEq @_fluxRecord, @_previousFluxRecord

  _notifySubscribers: -> if @_previousFluxRecord
    each subscriber in-array @_subscribers with subscriber @_fluxRecord, @_previousFluxRecord
    @_previousFluxRecord = null

  # subscriber is a function with the signature: (FluxEntry) ->
  # to unsubscribe, you must provide the exact same subscription function
  _subscribe:   (subscriber) -> pushIfNotPresent @_subscribers, subscriber
  _unsubscribe: (subscriber) -> removeFirstMatch @_subscribers, subscriber
