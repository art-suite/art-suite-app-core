import &StandardImport, &ModelRegistry

getFluxStore = -> _fluxStore ?= &FluxStore.fluxStore

retryExponent = 2

class FluxEntry extends BaseObject
  @warnCantSetField: warnCantSetField = (newFluxRecord, oldFluxRecord, field) ->
    newValue = newFluxRecord[field]
    oldValue = oldFluxRecord?[field]
    if newFluxRecord.hasOwnProperty(field) && newValue != oldValue
      console.warn "" #{FluxEntry.namespacePath}: Ignoring attempt to update the key of the Entry. Do not attempt to update the '#{field}' field. You attempted to change the key from #{formattedInspect oldValue} to #{formattedInspect newValue}.

  @warnUnsettableFields: warnUnsettableFields = (newFluxRecord, oldFluxRecord) ->
    warnCantSetField newFluxRecord, oldFluxRecord, :key
    warnCantSetField newFluxRecord, oldFluxRecord, :modelName

  # assumes FluxEntry "owns" the fluxRecord - it will alter the object by adding a "key" field
  constructor: (modelName, key) ->
    @_model       = models[modelName]
    @_autoReload  = @_model.autoReloadEnabled

    @_updatedAt = @_createdAt = toSeconds()
    @_reloadAt  = @_lastSuccessfulLoadAt = null
    @_tryCount  = 0

    @_fluxRecord = {} key, modelName, @createdAt, @updatedAt, status: pending

    @_subscribers = []
    @_previousFluxRecord = null

  @property :createdAt :updatedAt :reloadAt :lastSuccessfulLoadAt :tryCount
  @getter :previousFluxRecord :fluxRecord :subscribers :model :autoReload
  @getter
    dataChanged: -> !propsEq @_fluxRecord?.data, @_previousFluxRecord?.data
    fluxRecordChanged: -> !propsEq @_fluxRecord, @_previousFluxRecord
    subscriberCount:  -> @_subscribers.length
    key:              -> @_fluxRecord.key
    modelName:        -> @_fluxRecord.modelName
    status:           -> @_fluxRecord.status
    reloadAt:         -> @_fluxRecord.reloadAt

    age: ->
      now = toSeconds()
      reload:             now - @reloadAt             | 0
      created:            now - @createdAt            | 0
      updated:            now - @updatedAt            | 0
      lastSuccessfulLoad: now - @lastSuccessfulLoadAt | 0

    nextNetworkFailureRetryDelay: ->
      if 0 < m = @model.getMinNetworkFailureReloadSeconds()
        min
          m * Math.pow @tryCount ? 1, retryExponent
          @model.getMaxNetworkFailureReloadSeconds()

    nextServerFailureRetryDelay: ->
      if 0 < m = @model.getMinServerFailureReloadSeconds()
        min
          m * Math.pow @tryCount ? 1, retryExponent
          @model.getMaxServerFailureReloadSeconds()

    plainStructure: -> fluxRecord: @_fluxRecord, subscribers: @_subscribers
    hasSubscribers: -> @_subscribers.length > 0

  @setter
    fluxRecord: (newFluxRecord)->
      throw new Error "fluxRecord must be an object" unless newFluxRecord is Object
      warnUnsettableFields newFluxRecord, oldFluxRecord = @_fluxRecord

      @_fluxRecord extract key, modelName
      @_fluxRecord = newFluxRecord
      newFluxRecord.key           = key
      newFluxRecord.modelName     = modelName
      newFluxRecord.status        ?= pending
      newFluxRecord.createdAt     = @_createdAt
      newFluxRecord.updatedAt     = @_updatedAt = now = toSeconds()

      @_updateAutoReloadFields() if @_autoReload

    reloadAt: (reloadAt) -> if 0 < reloadAt
      delta = reloadAt - now = toSeconds()
      rangePerterbation = if delta < 80 then 1 else 15
      rangeMin = delta - rangePerterbation
      rangeMax = delta + rangePerterbation

      # queue reload if there isn't one already queued within [rangeMin, rangeMax]
      unless @_reloadAt && (oldDelta = @_reloadAt - now) >= rangeMin && oldDelta <= rangeMax

        _memoryLeakFreeReloader
          @modelName
          @key
          # +/- random pertubation so reloads are distributed
          @_reloadAt = reloadAt = now + rangeMin + (rangeMax - rangeMin) * Math.random()

      @_fluxRecord.reloadAt = @_reloadAt

  reload: -> @model.reload @key

  ##########################
    PRIVATE
  ##########################
  ## _memoryLeakFreeReloader
    IN: modelName <String>, key <String>, reloadAt: <Number>
    Schedule the reload, but don't hold on to any references to this entry.
    If this entry is gone by the time the reload comes around, we shouldn't hold on to this entry the whole time.
    NOTE: _memoryLeakFreeReloader is NOT a member function so "this" doesn't hold on to the object.
  _memoryLeakFreeReloader = (modelName, key, reloadAt) ->
    timeoutAt reloadAt, ->
      if floatEq reloadAt, entry = getFluxStore()._getEntry(modelName, key)?.reloadAt
        entry.reload()

  _updateAutoReloadFields: ->
    reloadDelta = if isSuccess @status
      @lastSuccessfulLoadAt = @_updatedAt
      @tryCount = 1
      @model.getStaleDataReloadSeconds()

    else if isFailure @status
      @tryCount += 1
      switch @status
        when networkFailure         then @nextNetworkFailureRetryDelay
        when serverFailure, failure then @nextServerFailureRetryDelay

    @_fluxRecord.lastSuccessfulLoadAt = @lastSuccessfulLoadAt
    @_fluxRecord.tryCount = @tryCount
    @reloadAt = if reloadDelta > 0 then @_updatedAt + reloadDelta else null

  _notifySubscribers: -> if @_previousFluxRecord
    each subscriber in @_subscribers
      subscriber @_fluxRecord, @_previousFluxRecord
    @_previousFluxRecord = null

  _updateFluxRecord: (updateFunction) ->
    @_previousFluxRecord ?= @_fluxRecord
    @setFluxRecord updateFunction?(@_fluxRecord) || {}
    if propsEq @_fluxRecord, @_previousFluxRecord
      @_previousFluxRecord = null

  # subscriber is a function with the signature: (FluxEntry) ->
  # to unsubscribe, you must provide the exact same subscription function
  _subscribe:   (subscriber) -> pushIfNotPresent @_subscribers, subscriber
  _unsubscribe: (subscriber) -> removeFirstMatch @_subscribers, subscriber
