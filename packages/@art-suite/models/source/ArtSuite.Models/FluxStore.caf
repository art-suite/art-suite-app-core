import &StandardImport, &ArtEpochedState, &Lib, {} &FluxEntry, &ModelRegistry

## FluxStore:
  a key-fields store
  'fields' are plain Objects with any fields with any values you want except:
    the 'key' field is set automatically to match the Object's key in the store
  Updates to values result in NEW Objects. A Value object is never altered.
  Epoched
  Supports change-notificaiton subscriptions per key.
class FluxStore extends EpochClass
  @singletonClass()

  constructor: -> @_reset()

  @getter
    :length
    models: -> ModelRegistry.models
    inspectedObjects: -> toInspectedObjects @_entriesByModelName
    status: ->
      entrySubscribers = 0
      modelCount = 0
      entryCount = 0
      reloadsPending = 0
      nextReload = Infinity
      now = toSeconds()

      each entries in @_entriesByModelName
        modelCount++
        each entry in entries
          entryCount++
          entrySubscribers += entry.subscriberCount

          if entry.reloadAt > now
            reloadsPending++
            nextReload = Math.ceil min nextReload, entry.reloadAt - now

      {} entryCount, entrySubscribers, modelCount, reloadsPending, nextReload

  get:                (modelName, key) -> @_getEntry(modelName, key)?.fluxRecord
  getSubscribers:     (modelName, key) -> @_getEntry(modelName, key)?.subscribers
  getEntriesForModel: (modelName)      -> @_entriesByModelName[modelName]

  @getter hardDeprecatedFunctionsAsMap :hasSubscribers

  ## subscribe
    subscribe to all changes to the fluxStore FluxEntry identified by modelName and Key.

    subscribers:
      are notified on all changes to the entry's:
        @fluxRecord object
        @subscribers list
      are NOT explicitly notified of when the entry is first added or removed
        However, when an entry is added, subscribers will be notified that a change happened.
        When an entry is removed, subscribers will be again notified, and the "subscribers" param will be [].
      See subscribeToStore for notifications about entries being added or removed

    IN:
      modelName: string
      key: string

      subscriber: (fluxRecord, previousFluxRecord) -> null
        IN:
          fluxRecord: plain object; the current value for the fluxRecord
          previousFluxRecord: plain object; the last value for the fluxRecord
        GUARANTEES:
          1. !propsEq fluxRecord, previousFluxRecord
          2. only called once per change

      initialFluxRecord: if set, and the key is not in the store, this is used
        as the initial value instead of calling "load" on the model.

    OUT:
      entry's current fluxRecord
      It is possible fluxRecord will be already populated with viable data (e.g. if initialFluxRecord was provided or if the model can load the data synchronously).
      If not, it'll have status: pending.

    side effects:
      vivifies a new entry with fluxRecord = {status: pending} if one isn't present
      calls ModelRegistry[modelName].load key if vivification occured
      Notifies all subscribers.

    returns: current fluxRecord for the entry
  subscribe: (modelName, key, subscriber, initialFluxRecord) ->
    @_queueChange {} modelName, key, addSubscriber: subscriber
    @_vivifyAndLoadEntry modelName, key, initialFluxRecord
    .fluxRecord

  ## unsubscribe
    inputs:
      modelName: string
      key: string
      subscriber: the exact same function (including closure) used to subscribe

    side effects:
      Notifies all subscribers.

    returns: null
  unsubscribe: (modelName, key, subscriber) -> @_queueChange {} modelName, key, removeSubscriber: subscriber

  ## update
    put updates or creates the record
    updateFunctionOrNewFluxRecord: can be:
      1) an arbitrary function: (oldFluxRecord) -> newFluxRecord
        oldFluxRecord will be null/undefined only if the record has not been created.
        do not alter oldFluxRecord
        must return a new Object or null/undefined (in which case an empty Object is created)
      2) a new Object to replace the existing object

    Notifies all subscribers.
    returns: updateFunctionOrNewFluxRecord
  update: (modelName, key, updateFunctionOrNewFluxRecord) ->
    validateInputs key is String, "Key must be a string." key
    @_queueChange {} modelName, key, updateFunction:
      if isFunction updateFunctionOrNewFluxRecord
            updateFunctionOrNewFluxRecord
      else  -> updateFunctionOrNewFluxRecord

    updateFunctionOrNewFluxRecord

  ########################
  # PRIVATE
  ########################

  # broken out for testing
  _reset: ->
    @_length = 0
    @_entriesByModelName = {}
    @_addedEntries = []

  _getEntriesForModelName: (modelName) -> @_entriesByModelName[modelName] ?= {}

  _getEntry: (modelName, key) ->
    validateInputs @models[modelName], "Expected valid modelName." modelName
    validateInputs key is String, "Expected 'key' to be a String." key
    @_getEntriesForModelName(modelName)[key]

  _addEntry: (modelName, key, initialFluxRecord) ->
    @_length++
    @_addedEntries.push entry = @_getEntriesForModelName(modelName)[key] = new FluxEntry modelName, key, initialFluxRecord
    entry

  _removeEntry: (entry) ->
    @_length--
    delete @_getEntriesForModelName(entry.fluxRecord.modelName)[entry.fluxRecord.key]
    entry

  ## _vivifyEntry
    EFFECT: ensures the entry exists
    OUT: existing or new entry the provided for modelName & key
  _vivifyEntry: (modelName, key) ->
    @_getEntry modelName, key
    ? @_addEntry modelName, key

  ## _vivifyAndLoadEntry
    Returns existing entry if there is one, otherwise it vivifies a "defaultFluxRecord" and starts the model.load.

    _vivifyAndLoadEntry solves the problem of two or more subscriptions starting in the same epoch
    on a new entry. Without this, we'd try to call "load" on the same model+key more than once.
    Ex: if we are loading remote images, loading the same remote image multiple times is a huge waste.

    OUT: entry
  _vivifyAndLoadEntry: (modelName, key, initialFluxRecord) ->
    @_getEntry modelName, key
    ? @_createAndInitEntry modelName, key, initialFluxRecord

  _getGlobalInitialFluxRecordForEntry: (modelName, key) ->
    if data = (global.artFluxInit ? global.artSuiteModelsInit)?[modelName]?[key]
      initialFluxRecord = {} data, status: success

  _createAndInitEntry: (modelName, key, initialFluxRecord) ->
    entry = @_addEntry modelName, key, initialFluxRecord ?= @_getGlobalInitialFluxRecordForEntry modelName, key

    entry.load() unless initialFluxRecord

    entry

  # this ensures we don't return the "change" Object which should not be exposed to clients
  _queueChange: (change) ->
    change extract modelName, key

    validateInputs @models[modelName],  "Expected 'modelName' to be a valid model name.", change
    validateInputs key is String,       "Expected 'key' to be a String.", change

    @queueItem change
    null

  ###########################
    EpochClass Overrides
  ###########################
  processEpochItems: (changes) ->
    updatedEntries = []
    removedEntries = []

    each {modelName, key, addSubscriber, removeSubscriber, updateFunction} in-array changes
      pushIfNotPresent updatedEntries, entry = @_vivifyEntry modelName, key
      if updateFunction        then entry._updateFluxRecord updateFunction
      else if addSubscriber    then entry._subscribe addSubscriber
      else if removeSubscriber then entry._unsubscribe removeSubscriber

    each entry in-array updatedEntries
      entry.updated()
      pushIfNotPresent removedEntries, @_removeEntry entry if entry.subscribers.length == 0

    each entry in-array @_addedEntries with entry.added()
    each entry in-array removedEntries with entry.removed()

    @_addedEntries = []
    null

  # TODO 2020-12-31: FluxStore should automatically bind to a standard global epoch cycle as the "models" epoched-state
  # bind to GlobalEpochCycle if not web-worker
  if GlobalEpochCycle = Neptune.Art.Engine?.Core?.GlobalEpochCycle
    GlobalEpochCycle.singleton.includeFlux FluxStore.singleton
