import &StandardImport

myTable = MyTable = null
setupPromise = null
setupWithMyTable = ->
  setupPromise ||= Promise.then ->
    Neptune.Art.Ery.PipelineRegistry._reset()
    {myTable} = class MyTable extends DynamoDbPipeline
      @addDatabaseFilters
        name:   "required string"
        email:  "required email"
        rank:               :number
        attributes:         :array

    {myCompoundKeyTable} = class MyCompoundKeyTable extends DynamoDbPipeline
      @keyFields "userId/postId"
      @addDatabaseFilters
        user:   "link"
        post:   "link"

    Promise.all []
      myCompoundKeyTable._vivifyTable()
      myTable._vivifyTable()

suite:

  basic: ->
    setup setupWithMyTable

    test "create then get", ->
      myTable.create
        data:
          name: "John"
          email: "foo@bar.com"

      .then (data) ->
        assert.isString data.id
        assert.isNumber data.createdAt
        assert.isNumber data.updatedAt
        myTable.get key: data
        .then (getData) ->
          assert.eq getData, data

    test "delete", ->
      createData = null

      myTable.create
        data:
          name: "John"
          email: "foo@bar.com"
          rank: 123
          attributes: ["adventurous", "charming"]

      .then (_createData) ->
        createData = _createData
        myTable.delete key: createData.id

      .then ->
        assert.rejects myTable.get key: createData.id

      .then (expectedError)->
        {response} = expectedError.info
        assert.eq response.status, missing
        "triggered catch"

    test "describeTable", ->
      myTable.dynamoDb.describeTable TableName: myTable.tableName
      .then ({Table}) ->
        assert.eq Table.AttributeDefinitions, [
          AttributeName: "id"
          AttributeType: "S"
        ]

  scan: ->
    setup ->
      setupWithMyTable()
      .then ->
        # delete all
        myTable.getAll()
        .then (users) ->
          each user in users
            myTable.delete user.id

    test "createX2 then scan" ->
      Promise.all []
        myTable.create data: name: :Alice email: :alice@gmail.com
        myTable.create data: name: :Bill  email: :bill@gmail.com
      .then -> myTable.getAll()
      .then (users)->
        assert.eq 2 users.length
        assert.eq
          :Alice :Bill
          array user from users with user.name
          .sort()

    test "multiple pages" ->
      Promise.all []
        myTable.create data: name: :Alice email: :alice@gmail.com
        myTable.create data: name: :Bill  email: :bill@gmail.com
      .then -> myTable.getAll returnResponse: true props: limit: 1
      .then ({props:{lastEvaluatedKey},data: users})->
        assert.eq 1 users.length
        # log {lastEvaluatedKey, users}
        assert.isObject lastEvaluatedKey
        myTable.getAll returnResponse: true props: {} limit: 1, lastEvaluatedKey
        .then ({props:{lastEvaluatedKey2},data: users2})->
          # log {lastEvaluatedKey2, users2}
          assert.doesNotExist lastEvaluatedKey2
          assert.eq
            :Alice :Bill
            array user from compactFlatten [users, users2] with user.name
            .sort()



    # test "createX3 then scan all pages" ->
    #   Promise.all []
    #     myTable.create data: name: :Alice email: :alice@gmail.com
    #     myTable.create data: name: :Bill  email: :bill@gmail.com
    #     myTable.create data: name: :Craig email: :craig@gmail.com
    #   .then -> myTable.getAll returnResponse: true props: limit: 1
    #   .then (users)->
    #     assert.eq 1 users.length

  update: ->
    setup setupWithMyTable

    test "using keys", ->

      createData = null

      myTable.create
        data:
          name: "John"
          email: "foo@bar.com"
          rank: 123
          attributes: ["adventurous", "charming"]

      .then (createData) ->
        myTable.update
          key: createData.id
          data: rank: 456

        .then (updatedData)->
          myTable.get key: createData.id
          .then (data)->
            assert.eq data, merge createData, updatedData

    test "non-existant record fails with status: missing", ->
      assert.rejects myTable.update
        key: randomString()
        data: rank: 123
      .then (rejectsWith) ->
        assert.eq rejectsWith.info.response.status, missing

    test "with createOk rejected without originatedOnServer", ->
      assert.rejects myTable.update
        props:
          createOk: true
          key: randomString()
          data: rank: 123
      .then (rejectsWith) ->
        assert.eq rejectsWith.info.response.status, clientFailure

    test "non-existant record works with createOk and originatedOnServer", ->
      pipelines.myCompoundKeyTable.update
        returnResponseObject: true
        originatedOnServer: true
        props:
          createOk: true
          key: userId: "123", postId: "abc"
      .then (response) ->
        assert.eq response.status, success

  "compound primary key": ->
    myManyToManyTable = null
    setup ->
      Neptune.Art.Ery.PipelineRegistry._reset()
      {myManyToManyTable} = class MyManyToManyTable extends DynamoDbPipeline
        @primaryKey "userId/postId"
        @addDatabaseFilters
          user: "required link"
          post: "required link"
          rank: :number

      myManyToManyTable.createTable()

    test "create, get and update", ->

      myManyToManyTable.create
        data:
          rank: 123
          userId: "abc123"
          postId: "xyz123"

      .then (data) ->
        assert.doesNotExist data.id
        myManyToManyTable.get key: data
        .then ({rank}) -> assert.eq rank, 123
        .then         -> myManyToManyTable.update key: data, data: merge data, rank: 456
        .then         -> myManyToManyTable.get key: data
        .then ({rank}) -> assert.eq rank, 456

    test "create fails with missing required field", ->

      assert.rejects myManyToManyTable.create
        data:
          rank:   123
          userId: :abc123

      .then (expectedError) ->
        assert.eq expectedError.info.response.status, clientFailure

